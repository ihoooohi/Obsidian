## 笔试原题

https://blog.csdn.net/weixin_30500289/article/details/99992205?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-99992205-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-99992205-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=8

https://blog.csdn.net/weixin_46373295/article/details/115294865?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-115294865-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-115294865-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=15

https://blog.csdn.net/weixin_46373295/article/details/115289930?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-115289930-blog-115294865.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-115289930-blog-115294865.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index[]

[https://blog.csdn.net/Xjheroin/article/details/105111363?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-105111363-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-105111363-blog-122660186.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6]

  

- [https://leetcode.com/discuss/interview-question/5524347/Microsoft-or-OA-or-On-campus-or-SDE-INTERN-2025](https://leetcode.com/discuss/interview-question/5524347/Microsoft-or-OA-or-On-campus-or-SDE-INTERN-2025)（明确贴了上面1466和2246的链接）
    
- [https://leetcode.com/discuss/interview-question/5878679](https://leetcode.com/discuss/interview-question/5878679) （2025 Summer Intern，提到string+DP medium）
    
- [https://leetcode.com/discuss/interview-experience/5984694/Microsoft-or-SWE-Internship-2025-or-India-or-Selected](https://leetcode.com/discuss/interview-experience/5984694/Microsoft-or-SWE-Internship-2025-or-India-or-Selected) （印度2025实习，提到medium LC-style + 3Sum）
    
- [https://leetcode.com/discuss/interview-question/5743615/MICROSOFT:-SWE-Internship-Test-_-FY25_-Off-Campus-or-5-sept-2024-or](https://leetcode.com/discuss/interview-question/5743615/MICROSOFT:-SWE-Internship-Test-_-FY25_-Off-Campus-or-5-sept-2024-or) （2024.9的FY25实习，给了自定义函数签名）
    
- [https://leetcode.com/discuss/post/6297558/microsoft-sde-oa-by-anonymous_user-tjkn](https://leetcode.com/discuss/post/6297558/microsoft-sde-oa-by-anonymous_user-tjkn) （最近2025 OA，贴了部分代码）
    

  

  

给你一个数组，两个人轮流从数组两端取数，取出的数之和大的为赢，假设两个人都以最佳选择取数，请问先开始者会赢还是会输？(后来才知道是leetcode486原题)

  

给你一个数组和一个数target，要你将数组中值等于target的数删除，并把后面的数前移，要求空间复杂度为O(1)。这个直接双指针很快就ac了。

  

### 2022.2.12微软暑期实习第二批笔试

3道题，给了160分钟。

A：给出2个字符串S和T。问能不能通过一些操作把S变成T，根据5种情况返回相应答案。

- 不用修改，return “NOTHING”
    
- 在S开头添加一个字母
    
- 在S中选一个字母变成另一个字母
    
- 在S中选2个字母不同的位置，交换这2个位置
    
- 无法变成相同
    

B：定义每把游戏可以在15分钟整（HH:00，HH:15，HH:30，HH:45）的时候开始，15分钟后结束。

按HH:MM的格式给出开始时间L和结束时间R，问在这段时间内能打几把游戏。

需要注意若R<L，则视为通宵，即包括L-23:59加上00:00-R。否则默认L和R在同一天内。

C：给一个整数x（1<=x<=1e9）。求大于x的最小的整数，满足不存在相邻位的数字相同。

例如，10的答案是12，98的答案是101。

  

### 微软暑期实习 笔试题目

记的不是很清楚了，简述下三题。

A题：给出一个字符串,要求将其切分为两个非空子串，使得至少存在一个子串字母x和字母y的出现次数相同，问有多少次这种合理的切分？例如axby有三种切分，分别是a/xby 和 ax/by 和 axb/y

B题：给出一个无自环和重边的无向图，每次操作都可以将图中所有度为0或者度为1的点及其连边删除掉，直到不能进行操作为止。求需要进行多少次操作

C题：给出一个长度为N的数组A，必须选出一段长度为R的连续子数组删除，剩下不同的数字的个数作为结果，求所有删除的情况中结果的最大数量（即删后不同的数字越多越好）

  

## 面经

https://www.nowcoder.com/discuss/353156373913477120?utm_source=chatgpt.com

  

## 原题解析

  

### C题：给出一个长度为N的数组A，必须选出一段长度为R的连续子数组删除，剩下不同的数字的个数作为结果，求所有删除的情况中结果的最大数量（即删后不同的数字越多越好）

  

看到连续子数组，联想到**滑动窗口**

要求统计不同的数字的个数，联想到**哈希表** unordered_map

  

给定了子数组长度为R，这道题采用**定长窗口，**定长窗口的模板如下：

```C++
for(int right = 0; right < n; right ++){
    add(nums[right]);
    
    //如果window的长度大于了定长R，则需要去除window中的left和移动left
    if(right - left + 1 > R){
         remove(nums[left]);
         left++;
    }
    
    //如果长度等于定长了，则进行一次判定，看是否符合条件，以及记录答案ans
    if(right - left + 1 == R){
        ...
        ans = ...
    }     
}
return ans；
```

  

这道题用两个哈希表 all 和 window，all记录数组，window记录窗口

先统计整个数组中不同数字的个数，先记为 int outside

  

在滑动过程中，进行**增量维护**，右扩一个值时，判断 if window[值] == all[值]，若是，则说明有数字都在window里，outside--；左缩一个值时，判断if window[值] == all[值] - 1, 若是，则说明有新数字被放出来了，outside++

  

最后取outside的最大值即可

  

完整代码如下：

```C++
 int func(vector<int> & nums, int R){
        unordered_map<int, int> all;
        unordered_map<int, int> window;
        int left = 0, ans = 0, n = nums.size();
        
        //记录所有不同的数字的个数作为outside初始值
        for(const int & k : nums){
            all[k]++;
        }
        int outside = all.size();
        
        //开始滑动
        for(int right = 0; right < n; right++){
            //右扩
            int x = nums[right];
            window[x]++;
            //判断增量
            if(window[x] == all[x]){
                outside--;
            }
            
            //左缩
            if(right - left + 1 > R){
                int y = nums[left]; 
                window[y]--;
                left++;
                
                if(window[y] == all[y] - 1){
                    outside++;
                }
                //清除个数为0的数字
                if(window[y] == 0) window.erase(y);
            }

            if(right - left + 1 == R){
                ans = max(ans, outside);
            }
        }
        return ans;
    }
```

  

### A题：给出一个字符串,要求将其切分为两个非空子串，使得至少存在一个子串字母x和字母y的出现次数相同，问有多少次这种合理的切分？例如axby有三种切分，分别是a/xby 和 ax/by 和 axb/y

  

?不知道这个x和y是不是写死的

  

```C++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int func(string s){
    int n = s.size(), ans = 0;
    int all_x = 0, all_y = 0, in_x = 0, in_y = 0;
    //先统计所有的x和y出现次数
    for(const char & k : s){
        if(k == 'x') all_x++;
        if(k == 'y') all_y++;
    }

    for(int right = 0; right < n - 1; right++){
        //计算切片内的x和y数量
        if(s[right] == 'x') in_x++;
        if(s[right] == 'y') in_y++;
        //用全部减切片内的值来表示第二个子串x和y的数量
        int out_x = all_x - in_x, out_y = all_y - in_y;
        //若有一个子串数量相等则计数加1
        if(in_x == in_y){
            ans++;
        } else if(out_x == out_y){
                ans++;
            }
    }
    return ans;
    
}

int main(){
   string s = "axby";
   cout << "answer is" << func(s) <<endl; 
}

//PS D:\MyProject\C++_test\output> & .\'main.exe'
//answer is 1
```

  

### 滑动窗口+单调队列（leetcode 239/1438）

  

### 给你一个数组，两个人轮流从数组两端取数，取出的数之和大的为赢，假设两个人都以最佳选择取数，请问先开始者会赢还是会输？(后来才知道是leetcode486原题)

#### 区间dp + 博弈

1.状态表示，确定dp 数组含义

  

`dp[i][j]` 表示在区间【i，j】内当前玩家的与对方的差值

  

2.确定状态转移方程

  

`dp[i][j]`等于玩家取走头（i）或尾（j）时，与剩下的区间的 dp 值的差

```C++
dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
```

  

3.初始化 dp 数组

  

当区间只剩一个时，先拿的当前玩家直接拿走，差值即是这个值的值

```C++
for(int k = 0; k < n; k++){
        dp[k][k] = nums[k];
}
```

  

4.根据 dp 表推断遍历顺序

![](https://xcnupv1k3y87.feishu.cn/space/api/box/stream/download/asynccode/?code=OWJkMThjMDE3MzY1ODdmODVkMDljZDBkNmJmNmMxZTRfVzVnb0NsUVI4WFp5TzNkcEpoY1ZrTGJDZ2lxUTNVOTlfVG9rZW46QUcwRGJrdDgwb0VWY1l4aFpYaGNLbUQwbmdYXzE3Njk2OTgxNTE6MTc2OTcwMTc1MV9WNA)

![](https://xcnupv1k3y87.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI4YzY5ZDU4OTk0M2JjZDE0YWNkNTI4MjA2MDkzZDlfbVc2YWNoNzlWb2pZc3N5aHpJMkE2NDI2Uzk0TWdxeTRfVG9rZW46WVo0aWJjUFUzb09Lc1N4eDJURmNxNDl2bnVlXzE3Njk2OTgxNTE6MTc2OTcwMTc1MV9WNA)

发现遍历顺序应是斜对角线往右上推，然后每条对角线按 i 遍历

  

斜对角线意味着 i-j 是个定值，也就是说是**区间长度**的递推

  

于是确定遍历顺序

  

```C++
for(int len = 2; len <= n; len++){
        for(int i = 0; i + len - 1 < n; i++){
        ...
        }
}        
```

完整代码如下

```C++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int k = 0; k < n; k++){ 
            dp[k][k] = nums[k];
        }

        for(int len = 2; len <= n; len++){
            for(int i = 0; i + len - 1 < n; i++){
                int j = i + len - 1;
                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);
            }
        }
        return dp[0][n-1] >= 0;
    }
};
```