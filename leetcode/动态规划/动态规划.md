## 动态规划是什么？

大问题的答案用子问题去解

动态规划的核心三要素

1. 状态表示
2. 状态转移方程
3. 初始化状态/边界
4.  **根据状态转移方程**确定遍历顺序
## 动规解题步骤

1. 确定dp数组含义
2. 确定状态转移方程（递推公式）
3. 初始化dp
4. 根据状态转移方程，**画出 dp 表推进情况**，确定遍历顺序

## 一维dp和二维dp

本质并没有什么区别，“几维dp”，只是状态里包含几个自变量

## 动规类型

### 背包问题
### 区间dp

什么是区间 dp？

区间 dp 就是 状态定义的下标是一个区间，即 `dp[i][j] 对应着区间 [i, j]`

什么时候用区间 dp？

就是当你发现**问题的状态始终被定义在一个不断缩小的区间内**

| **题目类型**   | **代表题（LeetCode）**     | **特点归纳**                                       |
| ---------- | --------------------- | ---------------------------------------------- |
| **博弈类**    | 486. 预测赢家 / 877. 石子游戏 | 每次从两端取，只需比较 $dp[i+1][j]$ 和 $dp[i][j-1]$。       |
| **拆解/组合类** | 312. 戳气球              | 每戳破一个，左右两边会相邻，形成新区间。                           |
| **回文类**    | 516. 最长回文子序列          | 判断 $s[i]$ 是否等于 $s[j]$，然后看内部 $[i+1, j-1]$ 是否回文。 |
| **构造类**    | 1039. 多边形三角剖分的最低得分    | 典型的需要枚举中间分割点 $k$ 的题目。                          |
## 动规题目

### 118.杨辉三角（dp + 构造二维数组）

初始化二维数组
```c++
vector<vector<int>> dp(numRows);
```
![[3a3b5c27db1afb0be78c9dbf61f51079.jpg|400]]

构造二维数组时，每遍历一行要resize该行的空间大小 `dp[n].resize(n+1, 1);`

### 486.预测赢家（区间 dp + 博弈）

1.状态表示，确定dp 数组含义

`dp[i][j]` 表示在区间【i，j】内当前玩家的与对方的差值

2.确定状态转移方程

`dp[i][j]`等于玩家取走头（i）或尾（j）时，与剩下的区间的 dp 值的差
```c++
dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
```

3.初始化 dp 数组

当区间只剩一个时，先拿的当前玩家直接拿走，差值即是这个值的值
```c++
for(int k = 0; k < n; k++){
	dp[k][k] = nums[k];
}
```

4.根据 dp 表推断遍历顺序

![[3ad71603a07c60615c8d9410d57c4598.jpg|500]]

![[8fbe86367e5c3749bb259a4da9b43574.jpg|500]]

发现遍历顺序应是斜对角线往右上推，然后每条对角线按 i 遍历

斜对角线意味着 i-j 是个定值，也就是说是**区间长度**的递推

于是确定遍历顺序

```c++
for(int len = 2; len <= n; len++){
	for(int i = 0; i + len - 1 < n; i++){
	...
	}
}	
```















