## 动态规划是什么？

大问题的答案用子问题去解

动态规划的核心三要素

1. 状态表示
2. 状态转移方程
3. 初始化状态/边界
4.  **根据状态转移方程**确定遍历顺序
## 动规解题步骤

1. 确定dp数组含义
2. 确定状态转移方程（递推公式）
3. 初始化dp
4. 根据状态转移方程，**画出 dp 表推进情况**，确定遍历顺序

## 一维dp和二维dp

本质并没有什么区别，“几维dp”，只是状态里包含几个自变量

## 动规类型

### 背包问题a

### 连续子数组/子串dp问题

连续子数组这种题，最常见的套路就是：
> **以 i 结尾的最优解** ← 由 i-1 的信息转移过来
### 区间dp

什么是区间 dp？

区间 dp 就是 状态定义的下标是一个区间，即 `dp[i][j] 对应着区间 [i, j]`

什么时候用区间 dp？

就是当你发现**问题的状态始终被定义在一个不断缩小的区间内**

| **题目类型**   | **代表题（LeetCode）**     | **特点归纳**                                       |
| ---------- | --------------------- | ---------------------------------------------- |
| **博弈类**    | 486. 预测赢家 / 877. 石子游戏 | 每次从两端取，只需比较 $dp[i+1][j]$ 和 $dp[i][j-1]$。       |
| **拆解/组合类** | 312. 戳气球              | 每戳破一个，左右两边会相邻，形成新区间。                           |
| **回文类**    | 516. 最长回文子序列          | 判断 $s[i]$ 是否等于 $s[j]$，然后看内部 $[i+1, j-1]$ 是否回文。 |
| **构造类**    | 1039. 多边形三角剖分的最低得分    | 典型的需要枚举中间分割点 $k$ 的题目。                          |
## 动规题目

### 118.杨辉三角（dp + 构造二维数组）

初始化二维数组
```c++
vector<vector<int>> dp(numRows);
```
![[3a3b5c27db1afb0be78c9dbf61f51079.jpg|400]]

构造二维数组时，每遍历一行要resize该行的空间大小 `dp[n].resize(n+1, 1);`

### 152.乘积最大子数组/53.最大子数组和

乘积最大子数组问题要注意，以i结尾的子数组的乘积最大值，可能是由以i-1结尾的子数组的**乘积最大值**或**乘积最小值**来的

因为负负得正
```c++
max_dp[i] = max(nums[i], max(max_dp[i-1]*nums[i], min_dp[i-1]*nums[i]));
```
### 486.预测赢家（区间 dp + 博弈）

1.状态表示，确定dp 数组含义

`dp[i][j]` 表示在区间【i，j】内当前玩家的与对方的差值

2.确定状态转移方程

`dp[i][j]`等于玩家取走头（i）或尾（j）时，与剩下的区间的 dp 值的差
```c++
dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
```

3.初始化 dp 数组

当区间只剩一个时，先拿的当前玩家直接拿走，差值即是这个值的值
```c++
for(int k = 0; k < n; k++){
	dp[k][k] = nums[k];
}
```

4.根据 dp 表推断遍历顺序

![[3ad71603a07c60615c8d9410d57c4598.jpg|500]]

![[8fbe86367e5c3749bb259a4da9b43574.jpg|500]]

发现遍历顺序应是斜对角线往右上推，然后每条对角线按 i 遍历

斜对角线意味着 i-j 是个定值，也就是说是**区间长度**的递推

于是确定遍历顺序

```c++
for(int len = 2; len <= n; len++){
	for(int i = 0; i + len - 1 < n; i++){
	...
	}
}	
```
### 32.最长有效括号（连续子数组/子串dp问题）

1.状态表示
**dp[i] = 以 i 结尾的最长【连续】有效括号长度**

2.状态转移方程
分类讨论：
- 若`dp[i]`为'('，则`dp[i] = 0;` 
- 若`dp[i]`为')'，则前面必须有'('与其匹配，此时再次分类：
	- 若`dp[i-1]`为'(' ，已经能够配对
		- ```c++
		  dp[i] = dp[i-2] + 2;
		  ```
	- 若`dp[i-1]`不是'(' （即 `dp[i-1] = ')'`）, `dp[i-1`] 和`dp[i]`都需要往前面找 '(' 配对
		- 若`dp[i-1`] 和`dp[i]`都能找到 '('
			- ```c++
			  if(dp[i-1] > 0 && s[i - 1 - dp[i-1] + 1 - 1] == '('){
				  dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2];
			  }
			  ```
		- 若其中有一个找不到，则`dp[i] = 0;`
			- ```c++
			  else{
				  dp[i] = 0;
			  }
			  ```

3.状态初始化
当只有一个元素时，只能为 0

所以`dp[0] = 0`

4.确定遍历顺序

令 i 从 1 开始遍历

观察转移方程中数组越界情况，做好防越界 
```c++
for(int i = 1; i < n; i++){
	if(dp[i] = ')'){
		dp[i] = (i >= 2 ? dp[i-2]:0) + 2;
	} else if(dp[i-1] > 0 && s[i - 1 - dp[i-1] + 1 - 1] == '(') {
		dp[i] = dp[i-1] + 2 + (i - dp[i-1] >= 2 ? dp[i - dp[i-1] - 2]:0);
	} else{
		dp[i] = 0;
	}
} 
``` 
  
  

  
 

