1. 二叉搜索树（Binary Search Tree，简称 BST）
	1. **二叉搜索树（BST）的中序遍历结果是有序的**
2. 高度平衡二叉树（Height-Balanced Binary Tree）
	1. **假设高度平衡二叉树中共有 NN 个节点，那么高度平衡二叉树的高度是 O(log⁡N)O(logN)**
3. 二叉树DFS框架
	```python
	def traverse(root):
	    if root is None:
	        return
	    # 前序位置
	    traverse(root.left)
	    # 中序位置
	    traverse(root.right)
	    # 后序位置
	   ```
4. 二叉树BFS框架
		==弹出一个元素，随即添加他的左右节点进队列==
		
		经典写法
```python
def levelOrderTraverse(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    while q:
        cur = q.popleft()
        # 访问 cur 节点
        print(cur.val)

        # 把 cur 的左右子节点加入队列
        if cur.left is not None:
            q.append(cur.left)
        if cur.right is not None:
            q.append(cur.right)
	
```
		记录层数写法(二叉树最小深度)
```python
q = deque()
q.append(root)
depth = 0
while q:
	sz = len(q)
	for _ in range(sz):
		cur = q.popleft()
		print("depth = {depth}, val = {cur.val}")
		if cur.left is not None:
			q.append(cur.left)
		if cur.right is not None:
			q.append(cur.right)
	depth += 1
```
		图写法
```python
class State: def __init__(self, node, depth): 
	self.node = node 
	self.depth = depth 
def levelOrderTraverse(root): 
	if root is None: 
		return
	q = deque()
	q.append(State(root, 1))
	while q:
		cur = q.popleft()
		print("depth = {depth}, val = {cur.val}")
		if cur.left is not None:
			q.append(State(cur.left, cur.depth+1))
		if cur.right is not None:
			q.append(State(cur.right, cur.depth+1))
```