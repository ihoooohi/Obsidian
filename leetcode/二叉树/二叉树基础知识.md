1. 二叉搜索树（Binary Search Tree，简称 BST）
	1. **二叉搜索树（BST）的中序遍历结果是有序的**
2. 高度平衡二叉树（Height-Balanced Binary Tree）
	1. **假设高度平衡二叉树中共有 NN 个节点，那么高度平衡二叉树的高度是 O(log⁡N)O(logN)**
3. 二叉树DFS框架
	```python
	def traverse(root):
	    if root is None:
	        return
	    # 前序位置
	    traverse(root.left)
	    # 中序位置
	    traverse(root.right)
	    # 后序位置
	   ```
4. 二叉树BFS框架
		==弹出一个元素，随即添加他的左右节点进队列==
		
		经典写法
```python
def levelOrderTraverse(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    while q:
        cur = q.popleft()
        # 访问 cur 节点
        print(cur.val)

        # 把 cur 的左右子节点加入队列
        if cur.left is not None:
            q.append(cur.left)
        if cur.right is not None:
            q.append(cur.right)
```
		记录层数写法(二叉树最小/最大深度)
```python
	q = deque()
	q.append(root)
	depth = 0
	while q:
		sz = len(q)
		for _ in range(sz):
			cur = q.popleft()
			print("depth = {depth}, val = {cur.val}")
			if cur.left is not None:
				q.append(cur.left)
			if cur.right is not None:
				q.append(cur.right)
		depth += 1
```
		图写法
```python
class State: 
	def __init__(self, node, depth): 
		self.node = node 
		self.depth = depth 
	def levelOrderTraverse(root): 
		if root is None: 
			return
		q = deque()
		q.append(State(root, 1))
		while q:
			cur = q.popleft()
			print("depth = {depth}, val = {cur.val}")
			if cur.left is not None:
				q.append(State(cur.left, cur.depth+1))
			if cur.right is not None:
				q.append(State(cur.right, cur.depth+1))
```
5. 后序遍历
	利用后序位置的题目，一般都使用「==分解问题==」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点 + 左右子树的子问题。
6. 二叉树的递归解法:
	- 遍历
		- 只专注于节点的操作，其他的再说
		- 节点不一定是单个，可组合
			- ![[Pasted image 20251106062146.png]]
	- 分解问题