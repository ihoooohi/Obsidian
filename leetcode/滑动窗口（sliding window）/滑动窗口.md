
滑动的窗口最重要的条件是**区间得连续**，适合子串、子数组问题

增量维护
## 窗口

### 基本信息

用两个指针，left和right指针来表示一个窗口

窗口长度：left - right  (闭区间`[left, right]`)

遍历窗口

```c++
for(int right = 0; right < n; right++){
}
```

窗口信息用一种**数据结构**存，如set，map，vector, deque等

### 不可变窗口/可变窗口

不可变窗口：
```c++
for (right = 0; right < n; right++) {
    // 1. 右端进
    add(s[right]);

    // 2. 超长就左端出
    if (right - left + 1 > k) {
        remove(s[left]);
        left++;
    }

    // 3. 长度刚好时判断，并记录答案
    if (right - left + 1 == k) {
        判断。。。
        ans = ...
    }
}
return ans;

```

可变窗口：

```c++
for (right = 0; right < n; right++) {
	//1.右端进
	add(s[right]);
	
	while(不符合条件){
		remove[s[left]];
		left++;
	}
	
	//此时窗口一定合法
	更新答案
}
return 答案

```
## 数据结构

根据题目要求。每个window都需要有一种数据结构来记录其中的相关信息，如哈希表，数组，单调队列等

### 单调队列（leetcode 239）

**维护窗口的最大/最小值**

与滑动窗口的配合：
如找最大值，右扩时，判断队列末尾是不是小于新增元素，若是则移除；左缩时，判断队首元素是不是left的，若是，移除队首元素，原来第二大的值变成队首（最大值）

```c++
//右扩
while(!dq.empty() && nums[dq.back()] <= nums[right]) dq.pop_back();
	dq.push_back(right);
//左缩
if(right - left + 1 > k){
	if(!dq.empty() && dq.front() == left) dq.pop_front();
	left++;
}
```
**注意点**：队列记录下标而不是值
## 缩放条件

### 1.重复

哈希表（`unordered_map`）

```c++
unordered_map<char, int> cnt;
...
while(cnt[key] > 1) { //重复了
}
```
### 2.同分异位词

数组 `vector`

```c++
vector<int> need(26, 0);
...
for(k : p){
	need[k - 'a']++;
}
```