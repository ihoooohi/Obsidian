## 什么是二分查找？

在一个的区间里，找到一个**基准**，其左右两侧（即大于它的和小于它的一侧）是单调的，每通过一次mid和基准的比较**丢弃**一半的答案，最终通过循环终止条件，得出R右侧与基准的确定的大小关系和L左侧与基准的确定的大小关系的范围，最终确定答案

**二分的前提是单调**

其实二分查找的题分为两种：

一类是**命中型二分**，特点是在**循环内**就能找到答案
- 704.二分查找
- 4.寻找两个正序数组的中位数
- 74 搜索二维矩阵
- 33 搜索旋转排序数组
另一类是**收敛型二分**，特点是要**循环结束**，区间收敛/缩小，边界分明才能找到答案
- 35.搜索插入位置
- 153 寻找旋转排序数组最小值
- 34.在排序数组中查找元素的第一个和最后一个位置

## 命中型二分

从最简单的二分查找讲起，**在一个升序数组中找到target的值**
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums) - 1
    for left <= right {
        mid := left + (right - left)/2
        if target == nums[mid] {
	        return mid
        }
        if target > nums[mid] {
            left = mid + 1
        } else { // target < nums[mid]
            right = mid - 1
        } 
    }
    return -1
}
```
在循环过程中能找到答案就返回


用 left mid right 来缩小区间

![[images/c179c655e5b853d8b348227752189aee.jpg]]

若target在mid左侧，则 `right = mid - 1` ,排除右侧区域
若target在mid右侧，则 `left = mid + 1` , 排除左侧区域

## 收敛型二分

用while循环不断重复这个过程，循环终止条件 `left > right`

若：
```go
while left <= right {
	mid = left + (right - left)/2
	if target > nums[mid] {
		left = mid + 1
	} else {
		right = mid - 1
	}
}
return left
```

则这个模板是找从小到大的顺序下，**升序情况下左侧第一个>= target** 的值的下标

`index := lowerBound(nums, target))
![[images/9f0c181118e87a5a91ebbb3c108748a0.jpg|400]]

若想找**升序情况下右侧第一个<=target** 的值的下标，可用

`index := lowerBound(nums []int, target + 1 ) - 1`

或者

变化等号的时机
```go
if target >= nums[mid] {
		left = mid + 1
	} else {
		right = mid - 1
	}
...
return right
`````
![[images/657b22f5bc2282155f25555956489cdc.jpg|400]]
## 旋转数组 + 二分查找

 找旋转数组的最小值（例子中的0）

```go
for left <= right {
	if nums[mid] > target {
		left = mid + 1 //left 左侧都是 > target的
	} else { //nums[mid] <= target
		right = mid - 1
	}
}
return nums[left]
```
![[images/1a79bafc1e89f3082805a1a2f4f865b7.jpg|550]]

## 寻找两个正序数组的中位数

![[images/8d4f090ddb55d349ef69ad9ae6dbefed.jpg|550]]

### 1.命中条件
```go
Aleft <= Bright && Bleft <= Aright
```

### 2.一定要用短的数组来切分进行二分
因为`j = leftcount - i` , 若用长的数组切分，i变化大，j变化发，j可能数组越界，所以要用短的数组
```text
nums1 = [1]                 (m = 1)   ← 短
nums2 = [2,3,4,5,6,7,8,9]   (n = 8)   ← 长
```
```text
leftCount = (9 + 1) / 2 = 5

i ∈ [0, 8]   （nums2）
j = leftCount - i = 5 - i

若i = 2，nums1[j]直接越界
```

### 3.处理i，j越界情况

![[images/da3aec57667045654d8dfd796c2c103a.jpg]]

解决办法：
```go
Aright := math.MaxInt
if i < m { Aright = nums[i]}

Aleft := math.MinInt
if i > 0 { Aleft = nums[i - 1]}
```
## 二分对象和二分位置

二分对象：
```go
left, right := 0, len(nums) - 1
```

二分位置：
```go
left, right := 0, len(nums)
```