## 什么是二分查找？

在一个的区间里，找到一个**基准**，其左右两侧（即大于它的和小于它的一侧）是单调的，每通过一次mid和基准的比较**丢弃**一半的答案，最终通过循环终止条件，得出R右侧与基准的确定的大小关系和L左侧与基准的确定的大小关系的范围，最终确定答案

**二分的前提是单调**

从最简单的二分查找讲起，**在一个升序数组中找到target的值**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums) - 1
    for left <= right {
        mid := left + (right - left)/2
        if target == nums[mid] {
	        return mid
        }
        if target > nums[mid] {
            left = mid + 1
        } else { // target < nums[mid]
            right = mid - 1
        } 
    }
    return -1
}
```
在循环过程中能找到答案就返回


用 left mid right 来缩小区间

![[c179c655e5b853d8b348227752189aee.jpg]]

若target在mid左侧，则 `right = mid - 1` ,排除右侧区域
若target在mid右侧，则 `left = mid + 1` , 排除左侧区域

用while循环不断重复这个过程，循环终止条件 `left > right` ,返回值取决于 mid 等于 target 时，让left移动了还是right移动了，一般是让right移动，则返回值应是left

![[f13b0c26bd5e6be6c6157524e4b9cece.jpg]]

模板：
```go
while left <= right {
	mid = left + (right - left)/2
	if target > nums[mid] {
		left = mid + 1
	} else {
		right = mid - 1
	}
}
return left
```

这个模板是找从小到大的顺序下，左侧第一个>= target 的值的下标

`index := lowerBound(nums, target))

若想找右侧第一个>=target 的值的下标，可用

`index := lowerBound(nums []int, target + 1 ) - 1`

或者

变化等号的时机
```go
if target >= nums[mid] {
		left = mid + 1
	} else {
		right = mid - 1
	}
...
return right
```

## 旋转数组 + 二分查找

 