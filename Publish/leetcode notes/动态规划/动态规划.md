## 动态规划是什么？

**大问题**的答案用**子问题**去解

动态规划的核心三要素

1. 状态表示
2. 状态转移方程
3. 初始化状态/边界
4.  **根据状态转移方程**确定遍历顺序
## 动规解题步骤

1. 确定dp数组含义
2. 确定状态转移方程（递推公式）
3. 初始化dp
4. 根据状态转移方程，**画出 dp 表推进情况**，确定遍历顺序

## 一维dp和二维dp

本质并没有什么区别，“几维dp”，只是状态里包含几个自变量

## 动规类型

### 背包问题

#### 01背包
背包容量：`W = 5`

|物品|重量|价值|
|---|---|---|
|1|1|15|
|2|3|20|
|3|4|30|


> 在不超过 5 重量的前提下，**价值最大是多少？**

01 背包的大问题之所以能拆成子问题， 是因为每个物品 i 都只有两种互斥决策：取或不取，而每种决策都会把问题缩小为  “前 i-1 **个**物品 + 对应剩余容量”的子问题，最优解就是这两种情况中的最大值。

`dp[i][j]` 定义：前i个物品（下标 0 ~ i-1），在背包容量为j时的最大价值
```c++
vector<int> dp(n+1);
```
- `i = 0`：一个物品都不选（基底）
- `i = n`：用完所有物品（终点）
```text
        j=0 1 2 3 4 5   ← 背包容量
i=0     0  0 0 0 0 0   ← 不选任何物品
i=1     0  . . . . .   ← 只考虑物品 0
i=2     0  . . . . .   ← 考虑物品 0,1
i=3     0  . . . . .   ← 考虑物品 0,1,2

```
```c++
dp[i][j] = max(
	dp[i-1][j], //不取 
	dp[i-1][j-w[i]] + v[i] //取
);
```

 因为两种情况都是从`dp[i-1]`推导下来的，所以可以压缩成**一维dp**

`dp[j]` 的含义：背包容量为j时的最大价值
```c++
dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
```
一维dp情况不意味着只有一个for循环，仍然需要遍历物品i，只是将其隐藏而已

且此时j的遍历需要**倒序**，因为不倒序，小的 `dp[j]` 会先被填充，物品可能会被选取多次，与01背包不符合

 ```c++
 for(int i = 0; i < n; i++){
	 for(int j = cap; j >= w[i]; j--){ //倒序
		 dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
	 }
 }
 ```
#### 完全背包
### 连续子数组/子串dp问题

连续子数组这种题，最常见的套路就是：
> **以 i 结尾的最优解** ← 由 i-1 的信息转移过来
### 区间dp

什么是区间 dp？

区间 dp 就是 状态定义的下标是一个区间，即 `dp[i][j] 对应着区间 [i, j]`

什么时候用区间 dp？

就是当你发现**问题的状态始终被定义在一个不断缩小的区间内**

| **题目类型**   | **代表题（LeetCode）**     | **特点归纳**                                       |
| ---------- | --------------------- | ---------------------------------------------- |
| **博弈类**    | 486. 预测赢家 / 877. 石子游戏 | 每次从两端取，只需比较 $dp[i+1][j]$ 和 $dp[i][j-1]$。       |
| **拆解/组合类** | 312. 戳气球              | 每戳破一个，左右两边会相邻，形成新区间。                           |
| **回文类**    | 516. 最长回文子序列          | 判断 $s[i]$ 是否等于 $s[j]$，然后看内部 $[i+1, j-1]$ 是否回文。 |
| **构造类**    | 1039. 多边形三角剖分的最低得分    | 典型的需要枚举中间分割点 $k$ 的题目。                          |
## 动规题目

### 118.杨辉三角（dp + 构造二维数组）

初始化二维数组
```c++
vector<vector<int>> dp(numRows);
```
![[3a3b5c27db1afb0be78c9dbf61f51079.jpg|400]]

构造二维数组时，每遍历一行要resize该行的空间大小 `dp[n].resize(n+1, 1);`

### 152.乘积最大子数组/53.最大子数组和

乘积最大子数组问题要注意，以i结尾的子数组的乘积最大值，可能是由以i-1结尾的子数组的**乘积最大值**或**乘积最小值**来的

因为负负得正
```c++
max_dp[i] = max(nums[i], max(max_dp[i-1]*nums[i], min_dp[i-1]*nums[i]));
```
### 486.预测赢家（区间 dp + 博弈）

1.状态表示，确定dp 数组含义

`dp[i][j]` 表示在区间【i，j】内当前玩家的与对方的差值

2.确定状态转移方程

`dp[i][j]`等于玩家取走头（i）或尾（j）时，与剩下的区间的 dp 值的差
```c++
dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
```

3.初始化 dp 数组

当区间只剩一个时，先拿的当前玩家直接拿走，差值即是这个值的值
```c++
for(int k = 0; k < n; k++){
	dp[k][k] = nums[k];
}
```

4.根据 dp 表推断遍历顺序

![[3ad71603a07c60615c8d9410d57c4598.jpg|500]]

![[8fbe86367e5c3749bb259a4da9b43574.jpg|500]]

发现遍历顺序应是斜对角线往右上推，然后每条对角线按 i 遍历

斜对角线意味着 i-j 是个定值，也就是说是**区间长度**的递推

于是确定遍历顺序

```c++
for(int len = 2; len <= n; len++){
	for(int i = 0; i + len - 1 < n; i++){
	...
	}
}	
```
### 32.最长有效括号（连续子数组/子串dp问题）

1.状态表示
**dp[i] = 以 i 结尾的最长【连续】有效括号长度**

2.状态转移方程
分类讨论：
- 若`dp[i]`为'('，则`dp[i] = 0;` 
- 若`dp[i]`为')'，则前面必须有'('与其匹配，此时再次分类：
	- 若`dp[i-1]`为'(' ，已经能够配对
		- ```c++
		  dp[i] = dp[i-2] + 2;
		  ```
	- 若`dp[i-1]`不是'(' （即 `dp[i-1] = ')'`）, `dp[i-1`] 和`dp[i]`都需要往前面找 '(' 配对
		- 若`dp[i-1`] 和`dp[i]`都能找到 '('
			- ```c++
			  if(dp[i-1] > 0 && s[i - 1 - dp[i-1] + 1 - 1] == '('){
				  dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2];
			  }
			  ```
		- 若其中有一个找不到，则`dp[i] = 0;`
			- ```c++
			  else{
				  dp[i] = 0;
			  }
			  ```

3.状态初始化
当只有一个元素时，只能为 0

所以`dp[0] = 0`

4.确定遍历顺序

令 i 从 1 开始遍历

观察转移方程中数组越界情况，做好防越界 
```c++
for(int i = 1; i < n; i++){
	if(dp[i] = ')'){
		dp[i] = (i >= 2 ? dp[i-2]:0) + 2;
	} else if(dp[i-1] > 0 && s[i - 1 - dp[i-1] + 1 - 1] == '(') {
		dp[i] = dp[i-1] + 2 + (i - dp[i-1] >= 2 ? dp[i - dp[i-1] - 2]:0);
	} else{
		dp[i] = 0;
	}
} 
``` 

### 416.分割等和子集（01背包，选不选问题）

题目意思理解为选取数组中的数，能不能凑成数组和的一半，**选不选问题**用dp解

`dp[j]` 表示能不能选几个数，其和凑成 j

状态转移方程
```c++
dp[j] = dp[j] || dp[j-nums[i]];
```

- 不选：跟之前`dp[j]`状态一样，之前true 现在就 true，之前 flase 现在就 fasle
- 选：跟之前`dp[j-nums[i]]`一样，之前能凑出现在就能凑出，之前不行现在就不行