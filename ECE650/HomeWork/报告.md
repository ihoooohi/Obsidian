# 作业 1 报告 – ECE650

## 第一部分：需求和开发概述

### 1. 开发目标与主要需求

本次作业的主要目标是实现一个自定义的内存分配器（Memory Allocator），实现 `malloc` 和 `free` 函数。核心需求包括：

- **内存管理**：使用 `sbrk()` 系统调用向操作系统申请堆内存。
- **分配策略**：实现两种不同的空闲块查找策略：
    1. **First Fit (FF / 首次适应算法)**：找到第一个满足大小要求的空闲块。
    2. **Best Fit (BF / 最佳适应算法)**：找到满足大小要求且剩余空间最小的空闲块。
- **内存回收**：实现 `free` 函数，能够将释放的内存块重新加入空闲列表，并与物理上相邻的空闲块进行合并（Coalescing）以减少碎片。
- **性能评估**：在执行时间和内存碎片率两个维度上比较 FF 和 BF 的性能。

### 2. 开发环境与工具

- **操作系统**：Ubuntu 22.04.5 LTS (GNU/Linux 6.6.87.2-microsoft-standard-WSL2 x86_64)
- **编程语言**：C 语言。
- **编译器**：GCC 。
- **辅助工具**：Make (构建管理)。

### 3. 报告结构

本报告分为三个部分：首先概述项目背景；其次详细阐述设计思路、数据结构及两种策略的具体实现逻辑；最后通过标准化测试套件对 FF 和 BF 进行性能对比分析。

---

## 第二部分：设计、实现和测试

### 1. 数据结构设计

![[images/e3298a32ea04ba6a2ce934bd99f48992.jpg]]

为了有效管理内存块，我设计了一个 BlockHeader 结构体（block_t），作为元数据（Metadata）存储在每个内存块的头部。该结构体包含如下字段：
- **状态与大小**：
    - size_t size：记录该数据块可用的载荷大小（不包含元数据本身）。
    - `bool isfree`：标记该块是否空闲。
- **空闲链表指针（逻辑结构）**：
    - block_t * next_free, block_t * prev_free：用于维护一个双向链表，仅连接空闲块。这使得分配器可以快速遍历空闲块而无需扫描已分配的块。
- **物理邻居指针（物理结构）**：
    - block_t * next_phys, block_t * prev_phys：指向物理内存地址上相邻的块。这两个指针用于在 `free` 时实现**立即合并（Immediate Coalescing）空的空间**

### 2. 实现逻辑

#### 基础机制

- **堆扩展**：当空闲列表中没有合适的块时，使用 `sbrk()` 移动程序中断点（Program Break）来申请新的内存区域。
- **对齐**：让header在8的倍数的地址，若不对齐会无法运行arm中或速度变慢
	- ```c
		  //block
		  typedef struct BlockHeader block_t;
		  struct BlockHeader{
		    bool isfree;
		    size_t size;
		    block_t * next_free;
		    block_t * prev_free;
		    block_t * next_phys;
		    block_t * prev_phys;
		  };
	   ```
	   最大的类型所占字节是8字节（size_t, block_t ），故应按照8字节对齐
	   ![[images/b9763f88dc951bdb2ca2261ca08adfe9.jpg]]
- **分裂 (Splitting)**：在分配内存时，如果找到的空闲块远大于请求大小（剩余空间超过 `sizeof(block_t) + MIN_SPLIT`），则将该块分裂为一个已分配块和一个新的较小空闲块，以通过利用剩余空间来减少内部碎片。MIN_SPLIT为8，因为按照8字节对齐，所以最小可用的空间为8字节
- **合并 (Coalescing)**：在 `free()` 被调用时，我检查当前块的物理左邻居（`prev_phys`）和右邻居（`next_phys`）。如果它们是空闲的，则将它们从空闲链表中移除，在此基础上合并成一个大块，最后将合并后的块重新插入空闲链表。

#### 策略实现对比

|特性|First Fit (FF)|Best Fit (BF)|
|:--|:--|:--|
|**算法描述**|从空闲链表头部开始遍历，**一旦遇到**大小 >= 请求大小的块，立即返回该块。|遍历**整个**空闲链表，寻找大小 >= 请求大小，且（块大小 - 请求大小）最小的那个块。|
|**分配速度**|**较快**。通常不需要遍历整个链表，平均查找时间较短。|**较慢**。必须遍历整个链表（除非找到恰好相等的大小）以确保找到最优解。|
|**空闲链表维护**|采用了 **LIFO (Last-In, First-Out)** 策略。新释放或合并的块被插入链表头部。这对 FF 意味着它倾向于复用最近释放的“热”缓存块。|同样采用 LIFO 插入策略，但这对查找没有帮助，因为 BF 总是需要遍历全表。|
|**代码复用**|复用了 `split_block`, `coalesce`, `insert_free` 等底层函数。|与 FF 共享底层机制，主要区别仅在于查找函数 `find_best_fit` 的逻辑。|

### 3. 测试方法

我使用了提供的测试套件进行功能验证和性能测试：

使用 `alloc_policy_tests` 或 `general_tests` 进行测试


---

## 第三部分：性能结果与分析

### 1. 测试结果数据

**First Fit (FF)**

![[images/Pasted image 20260121024416.png]]

**Best Fit (BF)**

![[images/Pasted image 20260121024510.png]]

### 2. 结果分析与差异解释

#### Equal Size Allocs (等大块分配)

- **分析**：在这种情况下，FF 和 BF 的表现通常非常接近。
- **原因**：BF 扫描全表没有带来任何优势，反而可能因为无谓的遍历导致时间略慢。

#### Small Range Random Allocs (小范围随机分配)

- **时间**：FF 通常显著快于 BF。因为空闲链表中可能包含成千上万个小块，BF 每次 malloc 都要经受 O(N) 的线性扫描惩罚，而 FF 往往在前几项就能找到合适的块。
- **碎片**：BF 在此场景下可能会表现出更好的内存利用率（碎片率更低），因为它倾向于保留较大的空闲块以应对未来可能的大请求，填补小的空隙。

#### Large Range Random Allocs (大范围随机分配)

- **表现**：这是最能体现策略差异的场景。
- **时间**：FF 依然保持速度优势。
- **碎片**：BF 这里通常具有优势。由于请求大小跨度极大，FF 经常会分割一个巨大的空闲块来满足一个小请求（例如用 64KB 块满足 32B 请求），导致产生大量细碎的外部碎片。而 BF 会试图找到那个 "小块" 来满足 32B 请求，从而保护了的大块的完整性，留给后续的大内存请求。但是该测试用例中，两种方案的碎片率差距不大

### 3. 结论与指导原则

- **First Fit** 适用于对**吞吐量（速度）**要求极高，且对内存利用率要求相对宽松的系统。它具有 O(1) ~ O(k) 的平均查找效率。
- **Best Fit** 适用于**内存资源受限**（如嵌入式系统），需要极力减少内存浪费的场景。虽然 CPU 开销较大，但它能更明智地管理空间，减少因碎片化导致的堆耗尽。

综上所述，在没有极端内存限制的通用计算环境中，**First Fit** 往往是更好的工程选择，因为它在性能和复杂性之间取得了很好的平衡。