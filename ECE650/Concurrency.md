## 一、什么是并发（Concurrency）

并发是多个执行单元在同一时间推进，通过**交替执行**来完成任务
## 二、什么是并行（Parallelism）

并行是多个执行单元在同一时刻**真正**同时进行，如cpu的多核
## 三、为什么并发会“乱”

### 1. 指令交错（interleaving）+ 共享内存 + 非原子操作

```c
x = x + 1
```

![[images/Pasted image 20260107142231.png]]

![[images/Pasted image 20260107142306.png]]
### 2. Race Condition

程序结果依赖于执行顺序

## 四、正确性的标准：可串行化（Serializability）

不管并发事务的实际执行如何交错，其最终效果都等价于某一种串行执行顺序。

## 五、临界区（Critical Section）

> **必须“看起来像原子操作”的那段代码。**

特点：

- 访问共享变量
    
- 并发执行会破坏可串行化
    

例子：

`x = x + 1;   // 整体是一个临界区`

---

## 六、锁（Lock / Mutex）

### 本质理解（你已经抓住的核心）

> **锁不是让代码更快，而是限制合法的执行顺序。**

作用：

- 一次只允许一个线程进入临界区
    
- 消除非法 interleaving
    
- 让临界区 **“看起来是原子操作”**
    

你说过一句非常准的话：

> **锁就是强行规定执行顺序（更准确：限制 interleaving）。**

---

## 七、顺序（Ordering）= 等待（Wait）

这是你理解并发的**分水岭观点**：

> **并发中的顺序，本质上就是等待（wait）。**

含义：

- 不能靠“代码写在前面”
    
- 只能靠“等某个事件发生”
    

标准模式：

```c
A:
  do_A();
  signal(event);

B:
  wait(event);
  do_B();

```

---

## 七、为什么叫“同步”你觉得怪（而你是对的）

### 问题根源

- 中文“同步” ≈ 同时
    
- 并发 synchronization ≈ 等待 / 约束顺序
    

### 你给出的更好理解：

> **执行协调**

非常准确，因为 synchronization 实际在做：

- 协调谁等谁
    
- 协调谁先进
    
- 协调阶段边界
    

---

## 八、事件同步（Event Synchronization）

解决的问题：

> **谁必须先发生，谁才能继续。**

不是互斥，而是顺序。

三种实现方式：

1. flag + while（原始，busy-wait）
    
2. semaphore
    
3. condition variable / monitor
    

---

## 九、信号量（Semaphore）

> **一个带规则的共享计数器，用于执行协调。**

用途：

- `N = 1` → mutex（互斥）
    
- `N > 1` → 限制并发数
    
- `N = 0` → 表达顺序（事件）
    

核心操作：

- `wait` → 等
    
- `signal` → 通知
    

---

## 十、Barrier（全局同步）

> **所有线程在这里互相等待，直到全部到齐再一起继续。**

本质：

- 集体 wait
    
- 阶段对齐
    

用途：

```text
Phase 1
Barrier
Phase 2

```

---

## 十一、锁的并发冲突

![[images/Pasted image 20260107155248.png]]

`while (condition) {}`

你准确识别出：

> **这是 polling / 轮询**

问题：

- 浪费 CPU
    
- 如果协议不完整 → 逻辑错误
    
这样的话同样可能多个线程拿到锁，造成race condition

---

## 十二、Peterson 算法（正确的锁结构）

关键点：

- 仍然是 while
    
- 但不是“傻等”
    
- 而是在等 **执行协调条件**
    

核心思想：

> **通过规则，逼其中一个线程让出来。**

关键变量：

- `interested[]`：我想不想进
    
- `turn`：冲突时谁让
    

你抓住的本质：

> **不是抢，是协议式让步。**

![[images/Pasted image 20260107155125.png]]

---

## 十三、为什么变量叫 process 不是 thread

原因：

- 历史背景（早期并发以进程为抽象）
    
- 算法本质只要求“并发执行单元”
    

结论：

> **process 在这里 ≈ thread**

---

## 十四、并发的完整认知框架（你现在已经掌握的）

```arduino
并发
↓
指令交错
↓
共享内存
↓
race condition
↓
不可串行化
↓
临界区
↓
执行协调
├── 互斥（lock）
├── 顺序（wait / signal）
└── 阶段（barrier）

```

---

## 十五、终极一句话总结（你的版本）

你现在完全可以这样理解并发：

> **并发是多个执行单元同时存在，其正确性依赖于对执行顺序的协调。**