下面我按原文**逐句（尽量逐字逐句）**翻译成中文；我会保留原来的段落结构、编号、分隔线、示例界面与符号，并在必要时把术语固定翻译（例如：Submarine=潜艇，Destroyer=驱逐舰，Battleship=战列舰，Carrier=航母；hit=命中，miss=未命中）。

---

## 开头说明

对于这次作业，你将要编写一个**基于文本**版本的游戏 **“battleship（战舰）”**。  
如果你不熟悉这个游戏，你可以在开始之前在这里阅读相关介绍：

[https://en.wikipedia.org/wiki/Battleship_(game)](https://en.wikipedia.org/wiki/Battleship_\(game\))

当然，不管你对这个游戏有多熟悉，请一定阅读我们这里的描述，因为我们会把它做得与常规版本**稍有不同**。

---

## 作业目标与结构

在我们深入你需要编写的战舰游戏之前，让我们花一点时间讨论这次作业的目标与结构。目标如下：  
(1) 帮助你思考**任务拆分、进度安排与规划**  
(2) 让你快速熟悉 **Java**  
(3) 帮助你看到**渐进式开发与测试**如何实际运作  
(4) 让你看到**设计思想**如何落地实践  
(5) 看看这些设计思想在面对**需求变化**时如何发挥作用

为了达成这些目标，我们把这次作业分成三部分：

- Version 1：以讲解式 walkthrough（手把手带做）完成
    
- Version 2：你独立完成
    
- Extra Credit：可选，且在学期后期截止
    

我们在本文档中列出了所有部分的要求。  
我们鼓励你**先完整读完**这份文档。注意：在真实世界里，当需求会发生变化时，你在完成 version 1 之前并不会提前看到“version 2”。然而在这里你能提前看到，这是为了配合我们的学习结构。

接下来我们会带你完成 Version 1。开始时，我们会非常“规定式”：告诉你要做什么、以及怎么做。随着 Version 1 的推进，我们会在每一步给出越来越少的细节。完成 Version 1 之后，你就能开始 Version 2——这部分你将完全独立完成。

你应该这样做：  
(1) 把这份 README 从头到尾读完  
(2) 花 20 分钟思考你会创建哪些类（classes），以及它们是否符合我们讨论过的设计原则。更详细说明在本文末尾的 “Next Steps” 部分。  
(3) 阅读并完成 walkthrough。注意这个 walkthrough 会花不少时间，因为它占了本次作业工作量的一半以上。我们期望这一步会分散到数周内完成。  
(4) 在测试等完成后，把你完成的 version 1 **git push** 上去  
(5) 完成 version 2  
(6) 通过 git push 提交 version 2

---

# =================

# | Version 1 |

# =================

我们将用文本界面来玩战舰游戏，棋盘为 **20 行高 × 10 列宽**（不过在文末 “extra credit” 会讨论图形界面）。因此，我们将使用坐标 **A0 到 T9**，如下所示：

---

## 0|1|2|3|4|5|6|7|8|9  
A | | | | | | | | | A  
B | | | | | | | | | B  
C | | | | | | | | | C  
D | | | | | | | | | D  
E | | | | | | | | | E  
F | | | | | | | | | F  
G | | | | | | | | | G  
H | | | | | | | | | H  
I | | | | | | | | | I  
J | | | | | | | | | J  
K | | | | | | | | | K  
L | | | | | | | | | L  
M | | | | | | | | | M  
N | | | | | | | | | N  
O | | | | | | | | | O  
P | | | | | | | | | P  
Q | | | | | | | | | Q  
R | | | | | | | | | R  
S | | | | | | | | | S  
T | | | | | | | | | T  
0|1|2|3|4|5|6|7|8|9

游戏有两位玩家：玩家 A 和玩家 B。虽然让 A 和 B 在两台电脑上通过网络对战会好很多，但我们不会要求你做这个（不过在文末 “extra credit” 会提到）。每位玩家有 10 艘船，如下：

- 2 艘 “Submarines（潜艇）”，大小为 1x2
    
- 3 艘 “Destroyers（驱逐舰）”，大小为 1x3
    
- 3 艘 “Battleships（战列舰）”，大小为 1x4
    
- 2 艘 “Carriers（航母）”，大小为 1x6
    

---

## 第一阶段：放置舰船

游戏第一阶段要求玩家放置自己的船。玩家 A 先放置，玩家 B 闭上眼睛。游戏应显示一张空棋盘（如上），并按如下方式说明放置规则：

---

玩家 A：你将放置以下舰船（它们都是矩形）。对每艘船，输入该船**左上角**的坐标，然后输入 H（表示水平）或 V（表示垂直）。例如 M4H 会把一艘船水平放置，从 M4 开始并向右延伸。你拥有：

2 艘 “Submarines（潜艇）”，大小为 1x2  
3 艘 “Destroyers（驱逐舰）”，大小为 1x3  
3 艘 “Battleships（战列舰）”，大小为 1x4  
2 艘 “Carriers（航母）”，大小为 1x6

然后游戏应对玩家 A 的每艘船进行提示，例如：

---

## 玩家 A：你想把一艘潜艇（Submarine）放在哪里？

如果位置无效（与其他船冲突、导致船超出棋盘边界等），你应向玩家解释问题，并要求他们重新放置。注意你应忽略大小写（因此 M4H、m4h、m4H、M4h 都相同）。如果放置成功，你应显示包含该船的棋盘。对应船型分别显示字母 s、d、b 或 c。  
例如：在 M4H 放置一艘潜艇、在 A0V 放置另一艘潜艇、并在 B2V 放置一艘驱逐舰后，你应显示：

---

## 当前海域（Current ocean）：  
0|1|2|3|4|5|6|7|8|9  
A s| | | | | | | | | A  
B s| |d| | | | | | | B  
C | |d| | | | | | | C  
D | |d| | | | | | | D  
E | | | | | | | | | E  
F | | | | | | | | | F  
G | | | | | | | | | G  
H | | | | | | | | | H  
I | | | | | | | | | I  
J | | | | | | | | | J  
K | | | | | | | | | K  
L | | | | | | | | | L  
M | | | |s|s| | | | M  
N | | | | | | | | | N  
O | | | | | | | | | O  
P | | | | | | | | | P  
Q | | | | | | | | | Q  
R | | | | | | | | | R  
S | | | | | | | | | S  
T | | | | | | | | | T  
0|1|2|3|4|5|6|7|8|9

显示棋盘后，提示放置下一艘船。重复此过程直到所有船都放置完。放置最后一艘船后你还应再显示一次棋盘（因此有 10 艘船时，如果放置过程中没有错误，你会显示棋盘 11 次）。

完成玩家 A 的放置后，为玩家 B 重复同样过程（玩家 A 在玩家 B 放置时应闭上眼睛）。注意：玩家 A 的船和玩家 B 的船属于不同的“海域（oceans）”，因此玩家 B 从空棋盘开始，可以把船放在任何位置（例如，即使玩家 A 在 A0 放了一艘潜艇，玩家 B 也可以在 A0 放船，因为它们是不同的 A0）。

---

## 第二阶段：轮流开火

接下来开始游戏。回合在两位玩家之间轮流进行，玩家 A 先手。首先向玩家 A 显示棋盘。你需要显示两样东西：

1. 玩家 A 自己的船
    
2. 玩家 A 对敌方（玩家 B）已经打出的命中/未命中记录
    

在该显示中，你将使用与之前相同的布局/符号，但：

- 用 `*` 表示你自己船被击中的部分
    
- 用 `X` 表示你打向敌方但未命中的格子（即对敌方船的“miss”）
    

例如：

---

## 玩家 A 的回合（Player A's turn）：  
你的海域（Your ocean） 玩家 B 的海域（Player B's ocean）  
0|1|2|3|4|5|6|7|8|9 0|1|2|3|4|5|6|7|8|9  
A s| | | | | | | |c| A A | | | | | | | | | A  
B s| |d| | | | | |c| B B | | | | | | | | | B  
C | |*| | | | | |c| C C | |X| | | | | | | C  
D | |d| | | | | |c| D D |X|d|d| | | | | | D  
E | | | | | | | |c| E E | |X| | | | | | | E  
F | |d| | | | | |c| F F | | | | | | | | | F  
G | |d| | | |b| | | G G | | | | | | | | | G  
H | |d| | | |b| | | H H | | | | | | | | | H  
I | | | | | |b| | | I I | | | | | | | | | I  
J | | | | | |b| | | J J | | |X| | | | | | J  
K c|c|c|c|c|c| | | | K K | | | | | | | | | K  
L | | | | | | | | | L L | | | |X| | | | | L  
M | | | |s|s| | | | M M | | | | | | | | | M  
N | | | | | | | | | N N | | | | | | | | | N  
O | | | | | |b| | | O O | | | | |s|s| | | O  
P | | | | | |b| | | P P | | | | | | | | | P  
Q | | | | | |b| | | Q Q | | | | | | | | | Q  
R | | | | | |b| | | R R | | | | | | | | | R  
S | | | | | | | | | S S | | | | | | | | | S  
T d|d|d| | | | | | | T T | | | | | | | | | T  
0|1|2|3|4|5|6|7|8|9 0|1|2|3|4|5|6|7|8|9

在上面的例子中，玩家 A 成功命中了玩家 B 的船共四个位置：

- O5：一艘潜艇
    
- O6：一艘潜艇
    
- D2：一艘驱逐舰
    
- D3：一艘驱逐舰
    

并且在 D1、C2、E2、J3 和 L4 处未命中玩家 B 的船（意味着那里没有船）。

玩家 A 自己的船被命中了一次，位置在 C2。

然后提示玩家 A 输入要开火的坐标。如果坐标无效，游戏应提示玩家 A 输入一个有效选择。然后游戏报告结果，例如：

---

## 你命中了一艘航母！（You hit a carrier!）

## 或者：

## 你未命中！（You missed!）

接着轮到玩家 B。向玩家 B 显示棋盘（因此左侧显示玩家 B 的状态：B 的所有船都可见；右侧显示玩家 A 的海域：只显示命中/未命中信息）。

游戏继续轮流进行，直到一方没有任何船剩余。当一方没有船时，另一方获胜。你的游戏应打印一条消息说明谁赢了，然后退出。

在继续 Version 2 之前，请检查……

- 你已满足 Version 1 的所有要求
    
- 你已严格且彻底地测试了你的代码
    
- 你已很好地写了代码注释
    
- 你已做了一个包含 version 1 代码的 git commit（也就是把 version 1 “交付”给客户）
    

---

# =================

# | Version 2 |

# =================

在完成战舰 version 1 之后，你的客户稍微改变了需求，你现在需要做 version 2。需求有三处变化：

---

## (1) 舰船设计的变化

为了让游戏更有趣一点，客户决定应该有一些不是纯矩形的不同船形。

具体来说，每位玩家现在有以下舰船类型：

- 2 艘 “Submarines（潜艇）”：1x2 的矩形（用 “s” 表示）
    
- 3 艘 “Destroyers（驱逐舰）”：1x3 的矩形（用 “d” 表示）
    
- 3 艘 “Battleships（战列舰）”：现在形状如下所示
    
    ```
             b      OR    b         bbb         b
            bbb           bb   OR    b     OR  bb
                          b                     b
    
             Up          Right      Down      Left
    ```
    
- 2 艘 “Carriers（航母）”：现在形状如下所示
    
    ```
                c                       c             
                c           cccc        cc         ccc
                cc   OR    ccc      OR  cc   OR  cccc     
                cc                       c         
                 c                       c
                 
               Up           Right     Down          Left
    ```
    

注意：潜艇与驱逐舰不变，仍然只有水平（H）与垂直（V）两个朝向。

战列舰与航母现在有新的形状，并有 4 个朝向（如上图所示）。这四个朝向分别是：上（U）、右（R）、下（D）、左（L），并且每个图下方都写了对应的朝向。

因此，放置战列舰或航母需要以 U、L、R 或 D 结尾的坐标，而不是 H 或 V。注意坐标仍然表示船的“左上角”。对于非矩形船，我们把这个左上角定义为：**能完全包住该船的最小矩形**的左上角。为澄清这一点，我们把每种船重新画一遍，并用以下方式标出左上角：

- 若该位置属于船的一部分，用大写字母标出
    
- 若该位置不属于船，用星号（*）标出
    

战列舰（Battleships）：  
*b OR B Bbb *b  
bbb bb OR b OR bb  
b b

```
           Up          Right      Down      Left
           
```

航母（Carriers）：  
C C  
c *cccc cc * ccc  
cc OR ccc OR cc OR cccc  
cc c  
c c

```
             Up           Right     Down          Left
```

---

## (2) 新的行动（moves）

玩家现在有 2 种新行动，每种行动每局最多使用 3 次。在玩家回合开始时，游戏应显示棋盘，提示玩家选择要使用的行动类型，然后提示该行动需要的任何信息。例如：

---

玩家 A 可用行动（Possible actions for Player A）：

F 向一个格子开火（Fire at a square）  
M 移动一艘船到另一个位置（Move a ship to another square）（剩余 2 次）  
S 声呐扫描（Sonar scan）（剩余 1 次）

## 玩家 A，你想做什么？

注意：一旦某个新行动的 3 次用完，你**可以**（但不必须）把该项从菜单中完全移除。你也**可以**在两种新行动都用完 3 次之后，直接像 version 1 那样进入“开火”行动。

### (2a) 移动舰船（Move ship）

使用此行动时，玩家选择自己的一艘船（游戏应提示选择哪艘船，玩家可以输入该船上任意一个属于该船的坐标）。然后提示玩家输入新的放置方式（位置 + 朝向，与初始放置相同）。该船随后移动到该位置。该船已有的任何损伤（被击中部分）应保持在船的相对位置上不变。

如果玩家选择了无效的位置，玩家会被重新提示选择行动（可能再次选择移动，或者选择不同的行动）。

注意：对方玩家的显示**不会**获得“这艘船移动了”的任何信息。如果对方之前命中过这艘船，命中标记仍然保留。如果对方之前在新位置打过未命中，那么这些未命中标记也仍然保留。

### (2b) 声呐扫描（Sonar scan）

当玩家选择此行动时，游戏提示输入声呐扫描的中心坐标。棋盘上的任何坐标都有效，即使扫描的一部分会超出棋盘边界。

然后游戏考虑以中心（C）为核心的如下形状区域：

```
                                *
                               ***
                              *****
                             ***C***
                              *****
                               ***
                                *
```

并报告该区域内每种船型所占格子的数量。例如：

---

## 潜艇占据 2 个格子（Submarines occupy 2 squares）  
驱逐舰占据 0 个格子（Destroyers occupy 0 squares）  
战列舰占据 5 个格子（Battleships occupy 5 squares）  
航母占据 1 个格子（Carriers occupy 1 square）

注意：不会报告该区域内任何船的具体位置，也不会报告每种船有多少艘——只报告占据了多少格。我们不知道“潜艇占据 2 个格子”是指一艘潜艇完全在区域内，还是两艘潜艇各有一格在区域内、另一格在区域外。

---

## (3) 与电脑对战（Play against computer）

游戏开始时，应提示用户选择玩家 A 和/或玩家 B 是人类玩家还是由电脑控制（任何组合都有效：人 vs 人、人 vs 电脑、电脑 vs 人、电脑 vs 电脑）。

你的电脑玩家不需要很聪明——不要求开发复杂 AI。电脑玩家可以把船放在预先指定或随机的位置（只要在棋盘上），并且可以按简单模式开火（按顺序遍历所有格子）或随机开火。不过，如果你想做更高级的电脑玩家，请看文末的 “extra credit”。

当电脑进行它的回合时，不应显示任何棋盘状态，也不应打印任何提示语。游戏应只打印行动结果（例如：玩家 B 在 D4 命中了你的潜艇！）。

如果电脑使用了特殊行动，游戏应说明“玩家 B 使用了一次特殊行动”，但不要说明是哪一种，也不要说明细节或结果。电脑玩家不要求必须使用特殊行动，但如果它想用也可以。

---

# =================

# | Extra Credit |

# =================

我们注意到 extra credit 是添加额外功能，并且在学期更后面截止。

上面的“游戏”在探索软件需求/设计变化方面是个不错的练习，但作为游戏本身很糟糕（两个人用一台电脑玩战舰，还要尽量不看到不该看的内容，实际上并不好用）。

---

*** 注意：extra credit 不与作业同时截止，***  
*** 而是可以在截止日期之后完成。 ***  
*** 你可以在 4 月 23 日之前提交 extra credit ***  
*** 如果/当你提交该 extra credit 时，请通知你的项目助教（project TA）***

---

我们为你提供 3 种 extra credit 的机会。你可以任选其一、其二或三者都做。这些内容比较开放，因此加分多少将依据作品质量决定。

(1) 图形用户界面（Graphical User Interface）  
把文本界面替换成图形界面。更精致、更直观的 UI 会获得更多分数。注意 UI 可以是任意形式：桌面、Web 或移动端。

(2) 网络对战（Networked game）  
让两名玩家能在不同电脑上进行游戏。你可以探索从简单的联网对局到更多特性：用户账户/认证、匹配机制等。

(3) 更智能的电脑玩家（Intelligent computer play）  
不再让电脑随机开火，而是编写智能 AI。可以是小而简单的改进（利用特殊行动、使用每次射击结果来决定下一步）获得少量分数；也可以是非常聪明复杂的策略获得更多分数。

对于这些 extra credit，你要加什么、怎么加、以及你还想改进游戏的其他任何内容，都由你决定！

---

# ================

# | Next Steps |

# ================

在进入 version 1 的 walkthrough 之前，我们希望你花大约 20 分钟思考 Battleship Version 1 的设计。

1. 先思考你可能需要哪些类与接口（你可以一边浏览这份 README 一边思考）。把你想到的类写下来。记住：类应该是名词。然后思考你的类在字段（fields）和方法（methods）上有哪些内容，以及它们之间的关系：  
    a. 写下每个类的主要方法。你不需要写完整方法签名，只需要用几词描述它做什么（例如“检查胜/负”）。  
    b. 写下类的字段。想想这些字段是基本类型（primitives）还是其他类（has-A 关系）。  
    c. 记下任何 is-A（继承）关系。
    
2. 接着，看看你的类列表并思考我们在课堂上讨论过的设计原则。  
    a. 每个类是否遵守单一职责原则（Single Responsibility Principle）？  
    b. 你的类之间耦合有多紧？  
    c. 你的类是否遵循依赖倒置（Dependency Inversion）？如果没有，应该引入什么接口？  
    d. 你的接口是否遵守接口隔离原则（Interface Segregation Principle）？如果没有，应如何拆分？  
    e. 你是否预计会出现代码重复（违反 DRY）？  
    f. 你的类是否遵守开闭原则（Open/Closed Principle）？尤其是，把代码改成 Version 2 会有多难？
    

到这里，我们建议你离开这份作业一段时间（你的大脑现在肯定已经被战舰折磨得很累了），稍后再回来。回来之后，读一遍你做出的设计让它重新进入你的脑中（你离开期间对它的想法是否变化了？如果是，也没关系）。

当你刷新了对你设计的记忆之后，打开 v1Overview.txt 并阅读它。我们将从这个高层设计过程的“think aloud（边想边说）”开始，带你一步步完成 Version 1。

---

如果你希望我“更严格逐字”到**每行都对照原文**（英文一行、中文一行），我也可以按“对照翻译版”重新排版给你。