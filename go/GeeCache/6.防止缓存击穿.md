之前的五天我们已经做完了一个简单的分布式缓存功能，现在我们要优化一下，避免**缓存击穿**

## 缓存可能遇到的问题

### 缓存击穿 （一个热点突然失效）

一个**热点 key** 在高并发下 **刚好过期**，大量请求同时访问数据库
```markdown
大量请求 → 热点缓存过期
        → 并发打 DB

```
常见场景
- 秒杀商品
- 热门商品详情页

### 缓存穿透 （查的东西根本不存在）

请求的数据**在缓存和数据库中都不存在**，导致每次请求都会直接打到数据库。

```markdown
请求 → 缓存 miss
     → 数据库 miss
     → 返回空
（下次请求还是一样）

```
主要危害

- 缓存完全失效
    
- 数据库被**持续**压测 （比如说1万条查询，每次都要访问数据库，每次又都是空）
    
- 隐蔽、不易发现
### 缓存雪崩（大量缓存一起失效）

**大量缓存同时失效**，或者缓存服务整体不可用，导致请求全部落到数据库。

```markdown
请求 → 缓存大面积失效
     → DB 被打崩
```

## 缓存击穿 --- singleflight（单飞机制）

### 一、回顾“缓存击穿”

缓存击穿是：

`热点 key 过期 → 大量并发请求 → 同时打 DB`

**singleflight 就是专门为了解这个问题设计的。**

---

### 二、如果没有 singleflight（问题）

假设有 1000 个并发请求查同一个 key：

```text
req1 → 查 DB
req2 → 查 DB
req3 → 查 DB
...
req1000 → 查 DB

```

👉 数据库被打爆

---

### 三、singleflight 出现后（直觉）

```text
req1 → 真正执行（查 DB）
req2~req1000 → 等 req1
req1 返回结果
→ req2~req1000 直接拿同一个结果

```

👉 **数据库只被查 1 次**

---

### 四、singleflight 的“本质”

> **请求合并（Request Coalescing）**

- 相同 key 的并发请求
    
- 合并成一次真实执行
    
- 结果共享

### singleflight具体实现

## 缓存穿透
### 1) 缓存空值（Negative Cache）✅最常用

当 DB 查不到时，把“空结果”也写进缓存，后续同样的不存在请求直接命中缓存，不再打 DB。

- **关键点**：空值缓存要设置 **较短 TTL**（比如 30s~5min），防止“刚创建的数据”被空值挡住太久。
    
- **适用**：大部分业务型穿透。
    

### 2) 布隆过滤器（Bloom Filter）✅高并发场景利器

把“可能存在的 key”提前放到布隆过滤器里：

- 请求进来先查 Bloom：
    
    - **判定不存在** → 直接拒绝/返回空（不查缓存/DB）
        
    - **判定可能存在** → 再走缓存/DB
        
- **优点**：挡掉大量“随机不存在 key”的攻击/误请求，DB 压力大幅下降。
    
- **注意**：有**误判（false positive）**：会把少量不存在当成可能存在，从而继续走后面流程；但不会把存在误判为不存在（前提是实现正确）。
    
- **落地**：可以用 RedisBloom / 自己实现 bitmap；需要考虑数据新增/删除如何更新 Bloom（新增好办，删除一般做“重建”或用 Counting Bloom）。
    

### 3) 参数校验 + 白名单/黑名单 + 限流 ✅入口治理

很多穿透来自“乱 key / 越界参数 / 恶意扫描”：

- ID 必须是正整数、长度限制、格式校验（UUID/手机号等）
    
- 对可疑来源做 **限流/封禁**（令牌桶、漏桶、滑动窗口）
    
- 业务上允许的话：对不存在的 ID 返回统一响应，避免被探测出规律
    

> 这类措施通常和（1）（2）一起用，效果最好。

### 4) 分层：本地缓存/短路表（存在性缓存）

对“是否存在”做一个轻量缓存（比如本地 Caffeine/Guava 或 Redis 里一张 set）：

- `exist:user:{id}` 只缓存存在性，TTL 较长
    
- 先判断存在性，再决定是否查详情缓存/DB  
    适合“对象很大，但存在性判断很便宜”的场景。
    

### 5) 兜底：对“空值”也做 singleflight（可选）

如果某个不存在 key 突然变热点（大量请求同一个不存在 ID），空值缓存没生效前也会打 DB：

- 可以对“回源查不存在”也合并，避免瞬间把 DB 打穿
    
- 一般作为补强，不是主方案
## 缓存雪崩

缓存雪崩 = **大量 key 在同一时间段失效/不可用**，导致请求集中打到 DB/下游，把整条链路拖垮。治理思路就两类：**别让它同时失效** + **失效了也扛得住**。

### 1) 过期时间“打散”✅最核心

- 给 TTL 加随机抖动：`ttl = baseTTL + rand(0, jitter)`
    
- 不同业务/不同维度的 key 用不同 baseTTL
    
- 对批量预热/批量写入的 key，务必加抖动，否则会“整点集体过期”
    

### 2) 多级缓存（本地 + Redis）✅抗抖动强

- 本地缓存（Caffeine/Guava）做 L1，Redis 做 L2  
    Redis 波动/瞬时过期时，本地还能顶一层。
    
- 热点 key 本地更有效，但注意容量、淘汰策略与一致性。
    

### 3) 热点 key：逻辑过期 + 后台刷新✅高可用常用

不要等 Redis 真实过期才刷新：

- value 里带 `expireAt`（逻辑过期时间）
    
- 读到“逻辑过期”仍返回旧值（保证可用）
    
- 同时触发一个异步刷新（用 singleflight/分布式锁限制只有一个刷新者）
    

> 适合“宁可短时间数据旧一点，也不能挂”的场景（首页、配置、榜单等）。

### 4) 回源保护：singleflight / 分布式锁 ✅防止 DB 被打穿

- 同一 key 失效时合并回源（singleflight）
    
- 或者 Redis 分布式锁（注意锁超时、续租、兜底）
    
- 锁没拿到的请求：可以短暂等一下/直接走旧值/快速失败（看业务）
    

### 5) 限流、熔断、降级 ✅“扛不住时别硬扛”

当缓存层出问题或大量失效已经发生：

- 接入层/服务层限流（按接口、按用户、按 IP）
    
- 熔断 DB/下游（避免把最脆弱的打死）
    
- 降级返回兜底数据/默认值/静态页（尤其是读多写少的页面）
    

### 6) 隔离与容量：别让缓存故障扩大

- 缓存集群做高可用（哨兵/集群/多 AZ），客户端要有重试退避、超时要短
    
- 连接池与线程池隔离（缓存访问别把业务线程拖死）
    
- 防止 Redis 慢查询：大 key、热 key、阻塞命令要治理
    

### 7) 预热与主动刷新 ✅避免“冷启动雪崩”

- 服务启动/发布后预热关键 key
    
- 定时刷新热点（异步任务），避免集中失效
    
- 大促/活动前做全链路压测和缓存预热
    

---

### 最推荐的一套“组合拳”

1. **TTL 随机抖动**（必做）
    
2. 热点 key 用 **逻辑过期 + 异步刷新（singleflight）**
    
3. 缓存故障时有 **限流/熔断/降级**
    
4. 视规模加 **本地缓存** 和 **预热**

