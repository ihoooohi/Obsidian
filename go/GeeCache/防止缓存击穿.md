之前的五天我们已经做完了一个简单的分布式缓存功能，现在我们要优化一下，避免**缓存击穿**

## 缓存可能遇到的问题

### 缓存击穿 （一个热点突然失效）

一个**热点 key** 在高并发下 **刚好过期**，大量请求同时访问数据库
```markdown
大量请求 → 热点缓存过期
        → 并发打 DB

```
常见场景
- 秒杀商品
- 热门商品详情页

### 缓存穿透 （查的东西根本不存在）

请求的数据**在缓存和数据库中都不存在**，导致每次请求都会直接打到数据库。

```markdown
请求 → 缓存 miss
     → 数据库 miss
     → 返回空
（下次请求还是一样）

```
主要危害

- 缓存完全失效
    
- 数据库被**持续**压测 （比如说1万条查询，每次都要访问数据库，每次又都是空）
    
- 隐蔽、不易发现
### 缓存雪崩（大量缓存一起失效）

**大量缓存同时失效**，或者缓存服务整体不可用，导致请求全部落到数据库。

```markdown
请求 → 缓存大面积失效
     → DB 被打崩
```

## 解决办法 --- singleflight（单飞机制）

## 一、回顾“缓存击穿”

缓存击穿是：

`热点 key 过期 → 大量并发请求 → 同时打 DB`

**singleflight 就是专门为了解这个问题设计的。**

---

## 二、如果没有 singleflight（问题）

假设有 1000 个并发请求查同一个 key：

```text
req1 → 查 DB
req2 → 查 DB
req3 → 查 DB
...
req1000 → 查 DB

```

👉 数据库被打爆

---

## 三、singleflight 出现后（直觉）

```text
req1 → 真正执行（查 DB）
req2~req1000 → 等 req1
req1 返回结果
→ req2~req1000 直接拿同一个结果

```

👉 **数据库只被查 1 次**

---

## 四、singleflight 的“本质”

> **请求合并（Request Coalescing）**

- 相同 key 的并发请求
    
- 合并成一次真实执行
    
- 结果共享