## 一、进程&线程&协程

| 层级  | 负责什么      | 关键词      | 调度   |
| --- | --------- | -------- | ---- |
| 进程  | 隔离        | 虚拟内存     | 操作系统 |
| 线程  | 干活（CPU执行） | CPU核心，并行 | 操作系统 |
| 协程  | 干活（程序执行）  | 并发，用户态切换 | 用户程序 |
**进程负责提供空间，线程消耗CPU，协程组织并发**

## 二、线程与协程

举个例子：
- 1 个 CPU 核心
    
- 1 个 OS 线程
    
- 3 个 goroutine（协程）
    
    - G1：等网络
        
    - G2：算点东西
        
    - G3：等网络

为什么要有协程？

因为如果没有协程，一个线程得先等待G1完成才能执行下一个，而将线程分为协程可以在等G1的时候，将CPU让出来去给G2

**线程被动等待，协程主动让出**


## 三、内存

程序所需的内存指的是RAM内存（例如电脑的内存条），一个程序（对应一个进程）所需的一段内存可这么表示
![[images/Pasted image 20260121162931.png|300]]
其中stack放代码中的局部变量，heap放需要动态分配的变量，static data 放全局变量， code放编译好的机器码

**变量所占的内存是怎么样的呢？**

首先以heap为例，这一段内存可以分为一个一个格子，每个格子占1字节，每个格子有1个地址，这个格子是内存的最小可寻址单位

![[images/5c305478cb12c230bf2fdd463f5fa36d.jpg|500]]

但不是一个变量就占1个格子即1字节，而要看变量类型，比如说char类型的占1字节，int类型4字节，double类型8字节

![[images/c996740833990f60feca0e51f29c80a7.jpg|500]]

但是不是说各种类型的变量直接一个挨着一个就行了，每种类型的变量开头所占的地址必须是类型所占字节的倍数，如int必须放在4的倍数的地址上

如果不这样，arm架构会报错，x86架构能运行但是速度慢，因为假如cpu按4字节来访问，不是倍数则要多次访问合并，是倍数一次就访问到了

![[images/11189ed975efa64f9ee817b8576cc348.jpg]]

所以这就引出了 **对齐（align）** 的概念

malloc分配内存的时候，不是说char要1个字节就分配1个字节，而是要看header的大小，若header中最大字段占8字节，那要给char分配8字节，剩余的7个字节用pad填充（详情可看[[报告]]）

![[images/b9763f88dc951bdb2ca2261ca08adfe9.jpg]]



