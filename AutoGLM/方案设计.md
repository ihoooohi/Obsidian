这是一个非常好的选题！把 **AI（不确定性）** 和 **系统设计（确定性）** 结合起来，正好能发挥你学习 **Go 语言（高并发、后端架构）** 和 **CS 基础（哈希、缓存算法）** 的优势。

这个项目的本质，其实就是给慢速的 AI 大脑装一个**“高速缓存（TLB）”**。

在操作系统中，CPU 查页表（Page Table）很慢，所以有了 TLB（快表）。

在你的系统中，AutoGLM 查视觉模型（VLM）很慢，所以我们要造一个 Semantic Cache（语义快表）。

以下是这个 **“基于 Go 的 UI 语义缓存系统”** 的详细设计方案。

---

### 1. 核心原理：为什么传统的 Redis Key-Value 不行？

通常我们做缓存：Key = MD5(Image)。

但在 GUI 场景下，这完全行不通。

- **问题**：屏幕顶部的“时间”在变（12:00 -> 12:01）、电量在变、甚至页面上有一个滚动的跑马灯广告。
    
- **结果**：只要有一个像素变了，`MD5` 就彻底变了，缓存命中率（Hit Rate）几乎为 **0**。
    

**解决方案**：我们需要一种**“模糊哈希” (Fuzzy Hashing)** 或 **“感知哈希” (Perceptual Hash, pHash)**。我们要判断的是“这两个页面**长得像不像**”，而不是“是不是完全一样”。

---

### 2. 系统架构设计

你可以把这个系统设计为一个独立的 **Go Microservice**。

- **Client (手机端/Agent)**: 负责截图，发送给 Go 服务。
    
- **Go Cache Service (你的核心工作)**:
    
    1. 接收截图。
        
    2. 计算截图的 **Fingerprint (指纹)**。
        
    3. 去 Redis 里查有没有相似的指纹。
        
    4. **Hit**: 直接返回坐标 `(x, y)`。
        
    5. **Miss**: 转发给 AutoGLM 进行推理，拿到结果后写入 Redis。
        
- **Redis**: 存储指纹和操作指令。
    

---

### 3. 关键技术点（你的简历亮点）

#### A. 核心算法：感知哈希 (pHash) + 汉明距离 (Hamming Distance)

这是你项目的“灵魂”。不要用 MD5，用 pHash。

- **原理**：pHash 通过离散余弦变换（DCT）提取图片的“低频信息”（比如整体轮廓、布局），忽略“高频信息”（比如噪点、微小的文字变化）。
    
- **Go 实现思路**：
    
    - 使用 Go 的图像处理库（如 `github.com/corona10/goimagehash`）。
        
    - **存储**：将 pHash 生成的 64位整数（uint64）存入数据库。
        
    - **查询**：查询时，不能用 `==`。要计算 **汉明距离**（两个 hash 二进制位不同的个数）。
        
    - **判定**：如果 `Distance < Threshold` (比如 5)，就认为这是同一个页面。
        

#### B. 数据结构设计：BK-Tree 或 向量检索

因为要算“距离”，Redis 原生的 KV 查找做不到“查找汉明距离最近的 Key”。

- **进阶方案 (加分项)**：在 Go 内存中维护一棵 **BK-Tree (Burkhard-Keller Tree)**。
    
    - 这是一种专门用于在大规模数据中查找“近似字符串/数值”的树形数据结构。
        
    - 你可以自己用 Go 实现一个简单的 BK-Tree，这体现了你对**数据结构**的掌握。
        
- **偷懒方案**：如果数据量不大，直接遍历 Redis 里最近的 50 条记录算距离。
    

#### C. 缓存淘汰策略 (Eviction Policy)

- 页面是会更新的（比如大麦网改版了）。
    
- **TTL (Time To Live)**：给每条缓存记录设置 1 小时的过期时间。
    
- **Feedback Loop (反馈机制)**：
    
    - 如果缓存返回了坐标 `(500, 500)`，但 Client 点击后发现**没反应**（页面没跳转），说明缓存**脏了 (Stale)**。
        
    - Client 发送 `Invalidate(Key)` 请求，Go 服务端删除该缓存，强制重新推理。
        

---

### 4. 代码实现模拟 (Go Version)

这是你将来写代码的雏形：

Go

```
package main

import (
	"fmt"
	"github.com/corona10/goimagehash"
	"image/jpeg"
	"os"
)

// 模拟数据库记录
type CacheEntry struct {
	PHash     *goimagehash.ImageHash
	ActionCMD string // 例如 "click(500, 1200)"
}

var memoryDB []CacheEntry // 实际项目中这里是 Redis 或 Vector DB

// 1. 计算图片的感知哈希
func computeHash(imagePath string) (*goimagehash.ImageHash, error) {
	file, _ := os.Open(imagePath)
	defer file.Close()
	img, _ := jpeg.Decode(file)
	
	// 使用 pHash 算法
	hash, err := goimagehash.PerceptionHash(img)
	return hash, err
}

// 2. 语义查找 (最核心的逻辑)
func findSemanticMatch(inputHash *goimagehash.ImageHash) (string, bool) {
	threshold := 5 // 汉明距离阈值，允许有 5 个 bit 的差异（容忍时间跳动、电量变化）

	for _, entry := range memoryDB {
		distance, _ := inputHash.Distance(entry.PHash)
		
		// 如果距离足够小，说明页面几乎一样
		if distance <= threshold {
			fmt.Printf("Cache Hit! Distance: %d\n", distance)
			return entry.ActionCMD, true
		}
	}
	return "", false
}

func main() {
	// 假设 DB 里已经存了大麦网详情页的 Hash
	// ... (初始化代码)

	// 新进来一张截图（哪怕时间变了，hash 也会很接近）
	currentHash, _ := computeHash("screenshot_now.jpg")

	// 查缓存
	action, hit := findSemanticMatch(currentHash)

	if hit {
		fmt.Println("执行加速操作:", action) // 耗时 < 10ms
	} else {
		fmt.Println("Cache Miss, 调用 AutoGLM 大模型推理...") // 耗时 > 1s
		// 推理完后，将 currentHash 和 结果存入 memoryDB
	}
}
```

---

### 5. 项目演进路线图 (Roadmap)

如果你要在简历上展示这个项目，建议分三步走：

#### 第一阶段：原型 (MVP)

- 用 Go 写一个 HTTP Server。
    
- 接收图片，计算 pHash。
    
- 用内存 Map 或 Slice 存 Hash。
    
- 实现基本的“相似度匹配”。
    
- **成果**：能够演示“第二次打开同一页面，响应时间从 2秒 变成 5毫秒”。
    

#### 第二阶段：工程化 (Engineering)

- 引入 **Redis** 持久化数据。
    
- 引入 **LRU Cache** (Go 标准库 `container/list`) 来管理内存，防止爆炸。
    
- 优化 pHash 计算性能（并发计算）。
    
- **成果**：具备高并发处理能力。
    

#### 第三阶段：高级特性 (Architecture)

- 实现 **BK-Tree** 加速查找（如果不做这个，O(N) 的查找在数据多了之后会慢）。
    
- 添加**“置信度校验”**：如果 pHash 距离有点大（比如 4-5 之间），不仅仅返回坐标，还告诉 Client “我不太确定，你最好检查一下”。
    

---

### 6. 简历上的话术 (Resume Summary)

做完这个项目，你可以在简历的“项目经历”里这样写：

> **基于感知哈希的高性能 UI 语义缓存系统 (Go, Redis)**
> 
> - **背景**：解决了 AutoGLM 视觉大模型在重复 UI 场景下推理延迟过高（>1s）的问题，旨在实现毫秒级的操作响应。
>     
> - **方案**：设计并实现了一个基于 **Go** 的中间件服务，采用 **Perceptual Hash (pHash)** 算法提取 UI 语义指纹，通过计算 **汉明距离 (Hamming Distance)** 实现非精确匹配（Fuzzy Matching），有效过滤了状态栏时间、电量变化带来的噪声。
>     
> - **优化**：实现了 **BK-Tree** 数据结构以优化相似度检索效率，将查询复杂度从 O(N) 降低至 O(logN)。
>     
> - **结果**：在重复场景下，将 Agent 的端到端响应时间从 **1.5s 降低至 20ms**，系统吞吐量（QPS）提升 **50 倍**。
>     

### 总结

这个项目非常适合你。

1. **它不难**：核心就是 pHash + 距离计算，没有复杂的分布式事务。
    
2. **它很“计算机”**：涉及到底层数据结构（树）、算法（Hash）、系统设计（缓存）。
    
3. **它蹭了热点**：虽然代码是 Go 写的，但它是为 **AI Agent** 服务的，这让你的简历看起来既有后端硬实力，又有前沿 AI 视野。
    

你想先从哪里开始？是搭建 Go 环境，还是先研究一下 pHash 算法？