### 一、Golang 基础与并发篇（必问！）

**1. Q: 你在项目里用到了 `sync.RWMutex`（读写锁），为什么不用互斥锁 `sync.Mutex`？**

> **考察点**：对锁颗粒度的理解和读写分离场景的认知。
> 
> **你的场景**：在 [manager.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 中，你使用 `sync.RWMutex` 来保护 [helpers](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 这个 map。
> 
> **参考答案**： "在我的项目中，`AIHelperManager` 不需要频繁创建或删除 AI 对话（写操作少），但是需要极其频繁地**读取**某个用户的会话信息（读操作多）。 如果用 `Mutex`，每次读都会阻塞其他读请求，并发性能很差。而 `RWMutex` 允许多个协程同时持有读锁，只要没有写操作在进行。这非常适合‘读多写少’的并发 map 场景，能显著提高并发读取的效率。"

**2. Q: Go 的 Map 是并发安全的吗？如果在多个 goroutine 里同时读写会发生什么？**

> **考察点**：Go 语言基础坑点。
> 
> **参考答案**： "不，Go 的原生 `map` **是非并发安全的**。 如果在没有加锁的情况下，多个 goroutine 同时对同一个 map 进行读写（或者并发写），程序会直接 **Panic**（报错信息通常是 `concurrent map writes`）。 所以我在 `AIHelperManager` 里操作 `map` 时，都严格使用了 [m.mu.Lock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 或 [m.mu.RLock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 来保证线程安全。"

**3. Q: 你了解 `defer` 吗？它的执行顺序是怎样的？**

> **考察点**：资源释放（Unlock, Close）的常识。
> 
> **参考答案**： "`defer` 用于**延迟执行函数**，通常用于释放锁（Unlock）或关闭文件/连接（Close）。 它的执行顺序是**后进先出（LIFO）**，即最后定义的 `defer` 最先执行。 在我的代码里，比如获取锁之后立刻写 [defer m.mu.Unlock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，**就是为了防止函数中间发生错误返回时忘记释放锁，导致死锁**。"

---

### 二、Gin 框架与 Web 开发篇

**4. Q: Gin 的中间件（Middleware）是怎么工作的？比如你的 JWT 鉴权。**

> **考察点**：责任链模式（Chain of Responsibility）和 [c.Next()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 的理解。
> 
> **你的场景**：[jwt.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)。
> 
> **参考答案**： "在我的 JWT 中间件里，我先解析 Header 里的 Token。如果 Token 验证失败，我会调用 [c.Abort()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，这样请求就会在这里截断，不会继续往后传给 Controller。 如果验证成功，我会用 [c.Set("userName", ...)](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 把用户信息存入上下文，然后调用 [c.Next()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 放行，让请求继续交给后续的 Handler 或后续的中间件 处理。Gin 的中间件类似于洋葱模型。 "
> 

**关于洋葱模型:**
```go
func A(c *gin.Context) {
    fmt.Println("A 前")
    c.Next() //立马去执行下一个中间件
    fmt.Println("A 后")
}

func B(c *gin.Context) {
    fmt.Println("B 前")
    c.Next()
    fmt.Println("B 后")
}

//执行效果
A 前
B 前
Controller
B 后
A 后
```

**5. Q: 你是怎么做项目配置管理的？为什么选 TOML？**

> **考察点**：工程化思维（刚才我们聊过的）。
> 
> **参考答案**： "我使用了 [config.toml](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 配合结构体映射来管理配置。 选 TOML 是因为它是为了配置文件而生的，比 JSON 支持注释，比 YAML 语法更明确（没有缩进歧义），而且在 Go 社区（如 Hugo, Dep）非常流行。这对维护数据库密码、API Key 等配置非常友好。"

 **7.你是否自定义过中间件？实现了什么？中间件执行顺序如何控制？**
  
>Gin 的中间件执行顺序遵循 **洋葱模型**（Onion Model），按添加顺序从外到内执行：
>
>1. **全局中间件**：在 `gin.Default()` 或 `r.Use()` 中添加，首先执行。
	gin.Default() 自带的两个全局中间件：Logger() 和 Recovery()
	 Logger()记录消耗的时间,**因为Gin的中间件是洋葱模型, 所以logger中间件最先执行,最后结束,故能记录消耗的时间**
>2. **分组中间件**：如 `AIGroup.Use(jwt.Auth())`，在路由分组级别添加，作用于该分组下的所有路由。
>3. **路由级中间件**：在单个路由上添加，具有最高优先级。
>
>- **请求进入**：中间件按添加顺序执行（正向）。
>- **处理器执行**：所有中间件执行完毕后，调用路由处理器。
>- **响应返回**：处理器完成后，中间件按逆序执行（反向），用于后处理（如日志记录）。

在项目中，有用到JWT 中间件，主要是应用于 `/AI`、`/image` 分组，确保这些接口需要认证，而 `/user` 分组无需认证。

---

### 第三阶段：认证与会话管理（JWT）
#### 9. 你使用 JWT 做登录态维持，那为什么不使用 session？

在单体架构中，Session 通常存储在服务器内存中即可，因为所有请求都由同一台服务器处理。  
但在微服务或分布式架构下，请求可能会被不同节点处理，如果每个节点各自维护 Session，就会导致**会话不一致**问题（例如用户在 A 节点登录，在 B 节点访问却变成未登录）。

因此，通常需要引入一个**集中式 Session 存储中间件**，如 **Redis、Memcached 或数据库**，来统一存储和共享 Session。  
这样无论请求落在哪个服务节点，都能从同一数据源中读取 Session，实现**登录状态一致**。

这也是为什么在分布式场景下，很多系统更倾向使用 **JWT 等无状态认证方案**，因为它**不依赖集中存储**，天然适合水平扩展。

session是存在服务器中, 而JWT则是存在用户自己的浏览器或是app里, 这样每次请求都在Header中带上JWT, 就不需要再通过 `session_id` 去查服务器

下面是区别表格：

|          |                                       |                                    |
| -------- | ------------------------------------- | ---------------------------------- |
| 特性       | **JWT（JSON Web Token）**               | **Session**                        |
| **存储位置** | 客户端（LocalStorage、Cookie 或 Header）     | 服务器端（内存、Redis、数据库）                 |
| **状态管理** | 无状态（Stateless），服务器不保存用户状态             | 有状态（Stateful），服务器维护会话数据            |
| **安全性**  | Token 自包含，支持签名校验；若被窃取可重放，需配合 HTTPS 使用 | Session ID 随机生成，依赖服务器安全；需防止会话固定攻击  |
| **扩展性**  | 适合分布式架构，无需共享状态或集中存储                   | 需在多节点间共享 Session（常用 Redis Cluster） |
| **性能**   | 无需查询服务器存储，只需验证签名，解析速度快                | 每次请求需查 Session 存储，存在额外 I/O 开销      |
| **过期控制** | Token 内含过期时间（exp），自动失效                | 服务器维护过期机制，可灵活调整                    |
| **注销机制** | 主动失效较难（需黑名单机制），适合短期 Token             | 可立即销毁 Session，支持主动注销               |
| **数据体积** | Token 含 Payload，体积较大，传输开销略高           | 仅传 Session ID，轻量高效                 |
### 三、数据库与中间件篇

**6. Q: RabbitMQ 在你项目里是用来干嘛的？**

> **考察点**：异步解耦的实际应用。
> 
> **你的场景**：代码中有 [NewWorkRabbitMQ](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 和 `Publish`。
> 
> **参考答案**： "在我的 AI 对话系统中，RabbitMQ 主要用于**异步解耦**和**流量削峰**。 比如用户的聊天记录入库，如果每次对话都同步写 MySQL，会拖慢接口响应。我可以把消息丢进 MQ 队列，然后让后台的一个 Worker 慢慢把消息写入数据库。这样用户聊天的体验更流畅，数据库的瞬时压力也变小了。"

**7. Q: 你的 Redis 用来存什么？如果 Redis 挂了怎么办？**

> **考察点**：缓存策略与高可用意识。
> 
> **你的场景**：通常用于 Session、验证码或热点数据缓存。
> 
> **参考答案**： "我用 Redis 存储了用户的 Token 黑名单（或者验证码等）。因为 Redis 是内存数据库，读写速度极快。 如果 Redis 挂了，简单的策略是可以降级查数据库（如果不存 Session 的话），或者直接报错保护后端。在生产环境中，应该配置 Redis Sentinel 或 Cluster 来保证高可用。"

---

### 四、核心业务（AI）篇

**8. Q: 你的 AI 对话功能是怎么维持上下文（Context）的？**

> **考察点**：对业务逻辑的理解。
> 
> **你的场景**：[manager.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 里的 [helpers](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) Map。
> 
> **参考答案**： "我设计了一个 `AIHelperManager`，它在内存中维护了一个 Map。 每个用户都有对应的 `AIHelper` 实例，这个实例里存储了该用户的历史对话记录（Message History）。 每次用户发新消息时，我会把之前的几轮对话记录一起打包发给 OpenAI/大模型接口，这样 AI 就能‘记得’我们之前聊了什么（具备上下文能力）。"

---

### 面试官可能会挖的一个坑（一定要注意！）

**Q: 你的 `AIHelperManager` 是存在内存里的，那如果服务重启了，用户的聊天上下文还在吗？**

- **你的现状**：看代码 [main.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) -> [readDataFromDB()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，你是在启动时从 MySQL 加载数据的。
- **完美回答**： "这是一个很好的问题！ 确实，单纯存在内存（Map）里，重启就会丢失。 所以为了数据持久化，我在服务启动（[main.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)）时，会调用 [readDataFromDB()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 方法，从 MySQL 数据库里把所有用户的历史消息读出来，重新构建内存里的 `AIHelper` 对象。这样即便重启，用户的会话状态也能恢复。"