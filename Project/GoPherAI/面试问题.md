### 一、Golang 基础与并发篇（必问！）

**1. Q: 你在项目里用到了 `sync.RWMutex`（读写锁），为什么不用互斥锁 `sync.Mutex`？**

> **考察点**：对锁颗粒度的理解和读写分离场景的认知。
> 
> **你的场景**：在 [manager.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 中，你使用 `sync.RWMutex` 来保护 [helpers](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 这个 map。
> 
> **参考答案**： "在我的项目中，`AIHelperManager` 不需要频繁创建或删除 AI 对话（写操作少），但是需要极其频繁地**读取**某个用户的会话信息（读操作多）。 如果用 `Mutex`，每次读都会阻塞其他读请求，并发性能很差。而 `RWMutex` 允许多个协程同时持有读锁，只要没有写操作在进行。这非常适合‘读多写少’的并发 map 场景，能显著提高并发读取的效率。"

**2. Q: Go 的 Map 是并发安全的吗？如果在多个 goroutine 里同时读写会发生什么？**

> **考察点**：Go 语言基础坑点。
> 
> **参考答案**： "不，Go 的原生 `map` **是非并发安全的**。 如果在没有加锁的情况下，多个 goroutine 同时对同一个 map 进行读写（或者并发写），程序会直接 **Panic**（报错信息通常是 `concurrent map writes`）。 所以我在 `AIHelperManager` 里操作 `map` 时，都严格使用了 [m.mu.Lock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 或 [m.mu.RLock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 来保证线程安全。"

**3. Q: 你了解 `defer` 吗？它的执行顺序是怎样的？**

> **考察点**：资源释放（Unlock, Close）的常识。
> 
> **参考答案**： "`defer` 用于**延迟执行函数**，通常用于释放锁（Unlock）或关闭文件/连接（Close）。 它的执行顺序是**后进先出（LIFO）**，即最后定义的 `defer` 最先执行。 在我的代码里，比如获取锁之后立刻写 [defer m.mu.Unlock()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，**就是为了防止函数中间发生错误返回时忘记释放锁，导致死锁**。"

---

### 二、Gin 框架与 Web 开发篇

**4. Q: Gin 的中间件（Middleware）是怎么工作的？比如你的 JWT 鉴权。**

> **考察点**：责任链模式（Chain of Responsibility）和 [c.Next()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 的理解。
> 
> **你的场景**：[jwt.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)。
> 
> **参考答案**： "Gin 的中间件类似于洋葱模型。 在我的 JWT 中间件里，我先解析 Header 里的 Token。如果 Token 验证失败，我会调用 [c.Abort()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，这样请求就会在这里截断，不会继续往后传给 Controller。 如果验证成功，我会用 [c.Set("userName", ...)](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 把用户信息存入上下文，然后调用 [c.Next()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 放行，让请求继续交给后续的 Handler 处理。"

**5. Q: 你是怎么做项目配置管理的？为什么选 TOML？**

> **考察点**：工程化思维（刚才我们聊过的）。
> 
> **参考答案**： "我使用了 [config.toml](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 配合结构体映射来管理配置。 选 TOML 是因为它是为了配置文件而生的，比 JSON 支持注释，比 YAML 语法更明确（没有缩进歧义），而且在 Go 社区（如 Hugo, Dep）非常流行。这对维护数据库密码、API Key 等配置非常友好。"

---

### 三、数据库与中间件篇

**6. Q: RabbitMQ 在你项目里是用来干嘛的？**

> **考察点**：异步解耦的实际应用。
> 
> **你的场景**：代码中有 [NewWorkRabbitMQ](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 和 `Publish`。
> 
> **参考答案**： "在我的 AI 对话系统中，RabbitMQ 主要用于**异步解耦**和**流量削峰**。 比如用户的聊天记录入库，如果每次对话都同步写 MySQL，会拖慢接口响应。我可以把消息丢进 MQ 队列，然后让后台的一个 Worker 慢慢把消息写入数据库。这样用户聊天的体验更流畅，数据库的瞬时压力也变小了。"

**7. Q: 你的 Redis 用来存什么？如果 Redis 挂了怎么办？**

> **考察点**：缓存策略与高可用意识。
> 
> **你的场景**：通常用于 Session、验证码或热点数据缓存。
> 
> **参考答案**： "我用 Redis 存储了用户的 Token 黑名单（或者验证码等）。因为 Redis 是内存数据库，读写速度极快。 如果 Redis 挂了，简单的策略是可以降级查数据库（如果不存 Session 的话），或者直接报错保护后端。在生产环境中，应该配置 Redis Sentinel 或 Cluster 来保证高可用。"

---

### 四、核心业务（AI）篇

**8. Q: 你的 AI 对话功能是怎么维持上下文（Context）的？**

> **考察点**：对业务逻辑的理解。
> 
> **你的场景**：[manager.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 里的 [helpers](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) Map。
> 
> **参考答案**： "我设计了一个 `AIHelperManager`，它在内存中维护了一个 Map。 每个用户都有对应的 `AIHelper` 实例，这个实例里存储了该用户的历史对话记录（Message History）。 每次用户发新消息时，我会把之前的几轮对话记录一起打包发给 OpenAI/大模型接口，这样 AI 就能‘记得’我们之前聊了什么（具备上下文能力）。"

---

### 面试官可能会挖的一个坑（一定要注意！）

**Q: 你的 `AIHelperManager` 是存在内存里的，那如果服务重启了，用户的聊天上下文还在吗？**

- **你的现状**：看代码 [main.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) -> [readDataFromDB()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，你是在启动时从 MySQL 加载数据的。
- **完美回答**： "这是一个很好的问题！ 确实，单纯存在内存（Map）里，重启就会丢失。 所以为了数据持久化，我在服务启动（[main.go](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)）时，会调用 [readDataFromDB()](vscode-file://vscode-app/d:/Application/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 方法，从 MySQL 数据库里把所有用户的历史消息读出来，重新构建内存里的 `AIHelper` 对象。这样即便重启，用户的会话状态也能恢复。"